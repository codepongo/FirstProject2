#include "stdafx.h"
#include "LMPEGVideo.h"

#include "../MPEG4VideoDec/vlctables.h"

/* take sign of a, either -1, 0, or 1 */
#define ZSGN(a)		(((a)<0) ? -1 : (a)>0 ? 1 : 0)	

namespace System
{
void idct(short *block);

namespace MediaShow
{

	/*
int divroundnearest(int i, int iDenom)
{
	ASSERT(iDenom > 0);

	if(i >= 0)
		return (i+(iDenom>>1))/iDenom;
	else
		return (i-(iDenom>>1))/iDenom;
}
*/

inline int getvariablebits(System::IO::CBitStream32* pBitStream, const vtab_byte table[], int maxlen)
{
	int value = pBitStream->looknbits(maxlen);
	pBitStream->skipnbits(table[value].len);
	return table[value].index;
}

template<class T>
int inline Sign(T a)
{
	return ZSGN(a);
}

enum
{
	field = 0,
	frame = 1,
};

/*
static int tab_intra_dc_mult[4] =
{
	8,
	4,
	2,
	1,
};
*/

static int cctab[12/*block*/][3/*chromaformat*/] =
{
	0,		0,		0,
	0,		0,		0,
	0,		0,		0,
	0,		0,		0,
	1,		1,		1,
	2,		2,		2,
	-1,	1,		1,
	-1,	2,		2,
	-1,	-1,	1,
	-1,	-1,	2,
	-1,	-1,	1,
	-1,	-1,	2,
};

static int scan[2][8][8] =
{
	// zigzag
	{
		0,	1,	5,	6,	14,	15,	27,	28,
		2,	4,	7,	13,	16,	26,	29,	42,
		3,	8,	12,	17,	25,	30,	41,	43,
		9,	11,	18,	24,	31,	40,	44,	53,
		10,	19,	23,	32,	39,	45,	52,	54,
		20,	22,	33,	38,	46,	51,	55,	60,
		21,	34,	37,	47,	50,	56,	59,	61,
		35,	36,	48,	49,	57,	58,	62,	63,
	},

	// alternate vertical
	{
		0,	4,	6,	20,	22,	36,	38,	52,
		1,	5,	7,	21,	23,	37,	39,	53,
		2,	8,	19,	24,	34,	40,	50,	54,
		3,	9,	18,	25,	35,	41,	51,	55,
		10,	17,	26,	30,	42,	46,	56,	60,
		11,	16,	27,	31,	43,	47,	57,	61,
		12,	15,	28,	32,	44,	48,	58,	62,
		13,	14,	29,	33,	45,	49,	59,	63,
	},
};

static short intra_dc_reset[4] =
{
	128,
	256,
	512,
	1024,
};

char* str_tab_B1[] =
{
	"1",
	"011",
	"010",
	"0011",
	"0010",
	"00011",
	"00010",
	"0000111",
	"0000110",
	"00001011",
	"00001010",
	"00001001",
	"00001000",
	"00000111",
	"00000110",
	"0000010111",
	"0000010110",
	"0000010101",
	"0000010100",
	"0000010011",
	"0000010010",
	"00000100011",
	"00000100010",
	"00000100001",
	"00000100000",
	"00000011111",
	"00000011110",
	"00000011101",
	"00000011100",
	"00000011011",
	"00000011010",
	"00000011001",
	"00000011000",
	"00000001000",
	NULL
};

vtab_byte tab_B1[] =
{
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 33,
11, 32,
11, 31,
11, 30,
11, 29,
11, 28,
11, 27,
11, 26,
11, 25,
11, 24,
11, 23,
11, 22,
11, 21,
10, 20,
10, 20,
10, 19,
10, 19,
10, 18,
10, 18,
10, 17,
10, 17,
10, 16,
10, 16,
10, 15,
10, 15,
8, 14,
8, 14,
8, 14,
8, 14,
8, 14,
8, 14,
8, 14,
8, 14,
8, 13,
8, 13,
8, 13,
8, 13,
8, 13,
8, 13,
8, 13,
8, 13,
8, 12,
8, 12,
8, 12,
8, 12,
8, 12,
8, 12,
8, 12,
8, 12,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 8,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
3, 1,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
};

/*
static vtab2 tab_B1[] =
{
1, 1, 0,
3, 2, 2,
3, 3, 1,
4, 2, 4,
4, 3, 3,
5, 2, 6,
5, 3, 5,
7, 7, 7,
7, 6, 8,
8, 10, 10,
8, 9, 11,
8, 8, 12,
8, 7, 13,
8, 6, 14,
8, 11, 9,
10, 22, 16,
10, 23, 15,
10, 21, 17,
10, 20, 18,
10, 19, 19,
10, 18, 20,
11, 29, 27,
11, 34, 22,
11, 33, 23,
11, 32, 24,
11, 31, 25,
11, 30, 26,
11, 35, 21,
11, 28, 28,
11, 27, 29,
11, 26, 30,
11, 25, 31,
11, 24, 32,
11, 8, 33,
0
};
*/

char* str_macroblock_types_P[] =
{
	"1",
	"01",
	"001",
	"00011",
	"00010",
	"00001",
	"000001",
	NULL
};

/*
vtab2 macroblock_types_P[] =
{
1, 1, 0,
2, 1, 1,
3, 1, 2,
5, 2, 4,
5, 1, 5,
5, 3, 3,
6, 1, 6,
0,
};
*/

vtab_byte macroblock_types_P[64] =
{
6, 6,
6, 6,
5, 5,
5, 5,
5, 4,
5, 4,
5, 3,
5, 3,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
1, 0,
};

char* str_macroblock_types_B[] =
{
	"10",
	"11",
	"010",
	"011",
	"0010",
	"0011",
	"00011",
	"00010",
	"000011",
	"000010",
	"000001",
	NULL
};

vtab_byte macroblock_types_B[64] =
{
6, 10,
6, 10,
6, 9,
6, 8,
5, 7,
5, 7,
5, 6,
5, 6,
4, 4,
4, 4,
4, 4,
4, 4,
4, 5,
4, 5,
4, 5,
4, 5,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 2,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
};

/*
vtab2 macroblock_types_B[] =
{
2, 3, 1,
2, 2, 0,
3, 3, 3,
3, 2, 2,
4, 2, 4,
4, 3, 5,
5, 2, 7,
5, 3, 6,
6, 2, 9,
6, 1, 10,
6, 3, 8,
0
};
*/

static int QuantizerScale[][2] =
{
	{0, 0},// (forbidden)
	{2,	1},
	{4,	2},
	{6,	3},
	{8,	4},
	{10,	5},
	{12,	6},
	{14,	7},
	{16,	8},
	{18,	10},
	{20,	12},
	{22,	14},
	{24,	16},
	{26,	18},
	{28,	20},
	{30,	22},
	{32,	24},
	{34,	28},
	{36,	32},
	{38,	36},
	{40,	40},
	{42,	44},
	{44,	48},
	{46,	52},
	{48,	56},
	{50,	64},
	{52,	72},
	{54,	80},
	{56,	88},
	{58,	96},
	{60,	104},
	{62,	112},
};

char* str_tab_B10[] =
{
	"00000011001",//	-16
	"00000011011",//	-15
	"00000011101",//	-14
	"00000011111",//	-13
	"00000100001",//	-12
	"00000100011",//	-11
	"0000010011",//	-10
	"0000010101",//	-9
	"0000010111",//	-8
	"00000111",//	-7
	"00001001",//	-6
	"00001011",//	-5
	"0000111",//	-4
	"00011",//	-3
	"0011",//	-2
	"011",//	-1
	"1",//	0
	"010",//	1
	"0010",//	2
	"00010",//	3
	"0000110",//	4
	"00001010",//	5
	"00001000",//	6
	"00000110",//	7
	"0000010110",//	8
	"0000010100",//	9
	"0000010010",//	10
	"00000100010",//	11
	"00000100000",//	12
	"00000011110",//	13
	"00000011100",//	14
	"00000011010",//	15
	"00000011000",//	16

	NULL
};

vtab_byte tab_B10[2048] =
{
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 32,
11, 0,
11, 31,
11, 1,
11, 30,
11, 2,
11, 29,
11, 3,
11, 28,
11, 4,
11, 27,
11, 5,
10, 26,
10, 26,
10, 6,
10, 6,
10, 25,
10, 25,
10, 7,
10, 7,
10, 24,
10, 24,
10, 8,
10, 8,
8, 23,
8, 23,
8, 23,
8, 23,
8, 23,
8, 23,
8, 23,
8, 23,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 9,
8, 22,
8, 22,
8, 22,
8, 22,
8, 22,
8, 22,
8, 22,
8, 22,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 10,
8, 21,
8, 21,
8, 21,
8, 21,
8, 21,
8, 21,
8, 21,
8, 21,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
8, 11,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 20,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
7, 12,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 19,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 18,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
4, 14,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 17,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
3, 15,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
1, 16,
};

/*
static vtab2 tab_B10[] =
{
1, 1, 16,
3, 2, 17,
3, 3, 15,
4, 3, 14,
4, 2, 18,
5, 2, 19,
5, 3, 13,
7, 6, 20,
7, 7, 12,
8, 9, 10,
8, 7, 9,
8, 6, 23,
8, 11, 11,
8, 8, 22,
8, 10, 21,
10, 20, 25,
10, 21, 7,
10, 19, 6,
10, 23, 8,
10, 18, 26,
10, 22, 24,
11, 33, 4,
11, 35, 5,
11, 25, 0,
11, 29, 2,
11, 31, 3,
11, 27, 1,
11, 34, 27,
11, 32, 28,
11, 30, 29,
11, 28, 30,
11, 26, 31,
11, 24, 32,
0,
};
*/

char* str_tab_B12[] =	// B-12
{
	"100",
	"00",
	"01",
	"101",
	"110",
	"1110",
	"11110",
	"111110",
	"1111110",
	"11111110",
	"111111110",
	"111111111",
	NULL
};

/*
static vtab2 tab_B12[] =	// B-12
{
2, 0, 1,
2, 1, 2,
3, 5, 3,
3, 6, 4,
3, 4, 0,
4, 14, 5,
5, 30, 6,
6, 62, 7,
7, 126, 8,
8, 254, 9,
9, 511, 11,
9, 510, 10,
0
};
*/

vtab_byte tab_B12[512] =
{
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
3, 4,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
4, 5,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
6, 7,
6, 7,
6, 7,
6, 7,
6, 7,
6, 7,
6, 7,
6, 7,
7, 8,
7, 8,
7, 8,
7, 8,
8, 9,
8, 9,
9, 10,
9, 11,
};

char* str_tab_B13[] =	// B-13
{
	"00",
	"01",
	"10",
	"110",
	"1110",
	"11110",
	"111110",
	"1111110",
	"11111110",
	"111111110",
	"1111111110",
	"1111111111",
	NULL
};

/*
vtab2 tab_B13[] =	// B-13
{
2, 1, 1,
2, 2, 2,
2, 0, 0,
3, 6, 3,
4, 14, 4,
5, 30, 5,
6, 62, 6,
7, 126, 7,
8, 254, 8,
9, 510, 9,
10, 1023, 11,
10, 1022, 10,
0
};
*/

vtab_byte tab_B13[1024] =	// B-13
{
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 0,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 1,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
2, 2,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
3, 3,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
6, 6,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
7, 7,
8, 8,
8, 8,
8, 8,
8, 8,
9, 9,
9, 9,
10, 10,
10, 11,
};

char* str_tab_B14[] =
{
	"10",	// End Of Block
//	"1", // s (NOTE2) (This code shall be used for the first (DC) coefficient in the block)
//	"11", // s (NOTE3) (This code shall be used for all other coefficients)
	"11",	// ??


	"011", // s
	"0100", // s
	"0101", // s
	"00101", // s
	"00111", // s
	"00110", // s
	"000110", // s
	"000111", // s
	"000101", // s
	"000100", // s
	"0000110", // s
	"0000100", // s
	"0000111", // s
	"0000101", // s
	"000001", //	// Escape
	"00100110", // s
	"00100001", // s
	"00100101", // s
	"00100100", // s
	"00100111", // s
	"00100011", // s
	"00100010", // s
	"00100000", // s
	"0000001010", // s
	"0000001100", // s
	"0000001011", // s
	"0000001111", // s
	"0000001001", // s
	"0000001110", // s
	"0000001101", // s
	"0000001000", // s

	"000000011101", // s
	"000000011000", // s
	"000000010011", // s
	"000000010000", // s
	"000000011011", // s
	"000000010100", // s
	"000000011100", // s
	"000000010010", // s
	"000000011110", // s
	"000000010101", // s
	"000000010001", // s
	"000000011111", // s
	"000000011010", // s
	"000000011001", // s
	"000000010111", // s
	"000000010110", // s
	"0000000011010", // s
	"0000000011001", // s
	"0000000011000", // s
	"0000000010111", // s
	"0000000010110", // s
	"0000000010101", // s
	"0000000010100", // s
	"0000000010011", // s
	"0000000010010", // s
	"0000000010001", // s
	"0000000010000", // s
	"0000000011111", // s
	"0000000011110", // s
	"0000000011101", // s
	"0000000011100", // s
	"0000000011011", // s

	"00000000011111", // s
	"00000000011110", // s
	"00000000011101", // s
	"00000000011100", // s
	"00000000011011", // s
	"00000000011010", // s
	"00000000011001", // s
	"00000000011000", // s
	"00000000010111", // s
	"00000000010110", // s
	"00000000010101", // s
	"00000000010100", // s
	"00000000010011", // s
	"00000000010010", // s
	"00000000010001", // s
	"00000000010000", // s
	"000000000011000", // s
	"000000000010111", // s
	"000000000010110", // s
	"000000000010101", // s
	"000000000010100", // s
	"000000000010011", // s
	"000000000010010", // s
	"000000000010001", // s
	"000000000010000", // s
	"000000000011111", // s
	"000000000011110", // s
	"000000000011101", // s
	"000000000011100", // s
	"000000000011011", // s
	"000000000011010", // s
	"000000000011001", // s

	"0000000000010011", // s
	"0000000000010010", // s
	"0000000000010001", // s
	"0000000000010000", // s
	"0000000000010100", // s
	"0000000000011010", // s
	"0000000000011001", // s
	"0000000000011000", // s
	"0000000000010111", // s
	"0000000000010110", // s
	"0000000000010101", // s
	"0000000000011111", // s
	"0000000000011110", // s
	"0000000000011101", // s
	"0000000000011100", // s
	"0000000000011011", // s
	NULL
};

char* _str_tab_B14[] =
{
	/*
	"10",	// End Of Block
//	"1", // s (NOTE2) (This code shall be used for the first (DC) coefficient in the block)
//	"11", // s (NOTE3) (This code shall be used for all other coefficients)
	"11",	// ??
*/

	"11", // s
	"100", // s
	"101", // s
	"0101", // s
	"0111", // s
	"0110", // s
	"00110", // s
	"00111", // s
	"00101", // s
	"00100", // s
	"000110", // s
	"000100", // s
	"000111", // s
	"000101", // s
	"00001", //	// Escape
	"0100110", // s
	"0100001", // s
	"0100101", // s
	"0100100", // s
	"0100111", // s
	"0100011", // s
	"0100010", // s
	"0100000", // s
	"000001010", // s
	"000001100", // s
	"000001011", // s
	"000001111", // s
	"000001001", // s
	"000001110", // s
	"000001101", // s
	"000001000", // s
	"00000011101", // s
	"00000011000", // s
	"00000010011", // s
	"00000010000", // s
	"00000011011", // s
	"00000010100", // s
	"00000011100", // s
	"00000010010", // s
	"00000011110", // s
	"00000010101", // s
	"00000010001", // s
	"00000011111", // s
	"00000011010", // s
	"00000011001", // s
	"00000010111", // s
	"00000010110", // s
	"000000011010", // s
	"000000011001", // s
	"000000011000", // s
	"000000010111", // s
	"000000010110", // s
	"000000010101", // s
	"000000010100", // s
	"000000010011", // s
	"000000010010", // s
	"000000010001", // s
	"000000010000", // s
	"000000011111", // s
	"000000011110", // s
	"000000011101", // s
	"000000011100", // s
	"000000011011", // s
	"0000000011111", // s
	"0000000011110", // s
	"0000000011101", // s
	"0000000011100", // s
	"0000000011011", // s
	"0000000011010", // s
	"0000000011001", // s
	"0000000011000", // s
	"0000000010111", // s
	"0000000010110", // s
	"0000000010101", // s
	"0000000010100", // s
	"0000000010011", // s
	"0000000010010", // s
	"0000000010001", // s
	"0000000010000", // s
	"00000000011000", // s
	"00000000010111", // s
	"00000000010110", // s
	"00000000010101", // s
	"00000000010100", // s
	"00000000010011", // s
	"00000000010010", // s
	"00000000010001", // s
	"00000000010000", // s
	"00000000011111", // s
	"00000000011110", // s
	"00000000011101", // s
	"00000000011100", // s
	"00000000011011", // s
	"00000000011010", // s
	"00000000011001", // s
	"000000000010011", // s
	"000000000010010", // s
	"000000000010001", // s
	"000000000010000", // s
	"000000000010100", // s
	"000000000011010", // s
	"000000000011001", // s
	"000000000011000", // s
	"000000000010111", // s
	"000000000010110", // s
	"000000000010101", // s
	"000000000011111", // s
	"000000000011110", // s
	"000000000011101", // s
	"000000000011100", // s
	"000000000011011", // s
	NULL
};

extern vtab_byte tab_B14[32768];

/*
static vtab2 tab_B14[] =
{
1, 1, 1,	//
2, 2, 0,
3, 3, 2,
4, 5, 4,
4, 4, 3,
5, 5, 5,
5, 7, 6,
5, 6, 7,
6, 7, 9,
6, 5, 10,
6, 4, 11,
6, 1, 16,
6, 6, 8,
7, 6, 12,
7, 5, 15,
7, 4, 13,
7, 7, 14,
8, 35, 22,
8, 33, 18,
8, 37, 19,
8, 36, 20,
8, 39, 21,
8, 38, 17,
8, 34, 23,
8, 32, 24,
10, 12, 26,
10, 11, 27,
10, 10, 25,
10, 15, 28,
10, 9, 29,
10, 14, 30,
10, 13, 31,
10, 8, 32,
12, 31, 44,
12, 24, 34,
12, 19, 35,
12, 16, 36,
12, 27, 37,
12, 20, 38,
12, 28, 39,
12, 18, 40,
12, 30, 41,
12, 21, 42,
12, 17, 43,
12, 29, 33,
12, 26, 45,
12, 25, 46,
12, 23, 47,
12, 22, 48,
13, 25, 50,
13, 24, 51,
13, 23, 52,
13, 22, 53,
13, 21, 54,
13, 20, 55,
13, 26, 49,
13, 19, 56,
13, 18, 57,
13, 17, 58,
13, 16, 59,
13, 31, 60,
13, 30, 61,
13, 29, 62,
13, 28, 63,
13, 27, 64,
14, 19, 77,
14, 30, 66,
14, 29, 67,
14, 28, 68,
14, 27, 69,
14, 26, 70,
14, 25, 71,
14, 24, 72,
14, 23, 73,
14, 22, 74,
14, 21, 75,
14, 20, 76,
14, 31, 65,
14, 18, 78,
14, 17, 79,
14, 16, 80,
15, 23, 82,
15, 22, 83,
15, 21, 84,
15, 20, 85,
15, 19, 86,
15, 18, 87,
15, 17, 88,
15, 24, 81,
15, 16, 89,
15, 31, 90,
15, 30, 91,
15, 29, 92,
15, 28, 93,
15, 27, 94,
15, 26, 95,
15, 25, 96,
16, 23, 105,
16, 18, 98,
16, 17, 99,
16, 16, 100,
16, 20, 101,
16, 26, 102,
16, 25, 103,
16, 24, 104,
16, 19, 97,
16, 22, 106,
16, 21, 107,
16, 31, 108,
16, 30, 109,
16, 29, 110,
16, 28, 111,
16, 27, 112,
0
};
*/

char* str_tab_B15[] =
{
"0110", //
"10", //s
"010", // s
"110", // s
"00101", // s
"0111", // s
"00111", // s
"000110", // s
"00110", // s
"000111", // s
"0000110", // s
"0000100", // s
"11100", // s
"0000111", // s
"0000101", // s
"1111000", // s
"000001", //
"11101", // s
"000101", // s
"1111001", // s
"00100110", // s
"1111010", // s
"00100001", // s
"00100101", // s
"00100100", // s
"000100", // s
"00100111", // s
"11111100", // s
"11111101", // s
"000000100", // s
"000000101", // s
"000000111", // s
"0000001101", // s

"1111011", // s
"1111100", // s
"00100011", // s
"00100010", // s
"00100000", // s
"0000001100", // s
"000000011100", // s
"000000010010", // s
"000000011110", // s
"000000010101", // s
"000000010001", // s
"000000011111", // s
"000000011010", // s
"000000011001", // s
"000000010111", // s
"000000010110", // s
"11111010", // s
"11111011", // s
"11111110", // s
"11111111", // s
"0000000010110", // s
"0000000010101", // s
"0000000010100", // s
"0000000010011", // s
"0000000010010", // s
"0000000010001", // s
"0000000010000", // s
"0000000011111", // s
"0000000011110", // s
"0000000011101", // s
"0000000011100", // s
"0000000011011", // s

"00000000011111", // s
"00000000011110", // s
"00000000011101", // s
"00000000011100", // s
"00000000011011", // s
"00000000011010", // s
"00000000011001", // s
"00000000011000", // s
"00000000010111", // s
"00000000010110", // s
"00000000010101", // s
"00000000010100", // s
"00000000010011", // s
"00000000010010", // s
"00000000010001", // s
"00000000010000", // s
"000000000011000", // s
"000000000010111", // s
"000000000010110", // s
"000000000010101", // s
"000000000010100", // s
"000000000010011", // s
"000000000010010", // s
"000000000010001", // s
"000000000010000", // s
"000000000011111", // s
"000000000011110", // s
"000000000011101", // s
"000000000011100", // s
"000000000011011", // s
"000000000011010", // s
"000000000011001", // s

"0000000000010011", // s
"0000000000010010", // s
"0000000000010001", // s
"0000000000010000", // s
"0000000000010100", // s
"0000000000011010", // s
"0000000000011001", // s
"0000000000011000", // s
"0000000000010111", // s
"0000000000010110", // s
"0000000000010101", // s
"0000000000011111", // s
"0000000000011110", // s
"0000000000011101", // s
"0000000000011100", // s
"0000000000011011", // s
	NULL
};

#if 0
static vtab tab_B15[] =
{
4, 6,
2, 2,
3, 2,
3, 6,
5, 5,
4, 7,
5, 7,
6, 6,
5, 6,
6, 7,
7, 6,
7, 4,
5, 28,
7, 7,
7, 5,
7, 120,
6, 1,
5, 29,
6, 5,
7, 121,
8, 38,
7, 122,
8, 33,
8, 37,
8, 36,
6, 4,
8, 39,
8, 252,
8, 253,
9, 4,
9, 5,
9, 7,
10, 13,
7, 123,
7, 124,
8, 35,
8, 34,
8, 32,
10, 12,
12, 28,
12, 18,
12, 30,
12, 21,
12, 17,
12, 31,
12, 26,
12, 25,
12, 23,
12, 22,
8, 250,
8, 251,
8, 254,
8, 255,
13, 22,
13, 21,
13, 20,
13, 19,
13, 18,
13, 17,
13, 16,
13, 31,
13, 30,
13, 29,
13, 28,
13, 27,
14, 31,
14, 30,
14, 29,
14, 28,
14, 27,
14, 26,
14, 25,
14, 24,
14, 23,
14, 22,
14, 21,
14, 20,
14, 19,
14, 18,
14, 17,
14, 16,
15, 24,
15, 23,
15, 22,
15, 21,
15, 20,
15, 19,
15, 18,
15, 17,
15, 16,
15, 31,
15, 30,
15, 29,
15, 28,
15, 27,
15, 26,
15, 25,
16, 19,
16, 18,
16, 17,
16, 16,
16, 20,
16, 26,
16, 25,
16, 24,
16, 23,
16, 22,
16, 21,
16, 31,
16, 30,
16, 29,
16, 28,
16, 27,
0
};
#endif

extern vtab_byte tab_B15[65536];

/*
static vtab2 tab_B15[] =
{
2, 2, 1,
3, 2, 2,
3, 6, 3,
4, 7, 5,
4, 6, 0,
5, 29, 17,
5, 5, 4,
5, 7, 6,
5, 6, 8,
5, 28, 12,
6, 4, 25,
6, 6, 7,
6, 5, 18,
6, 7, 9,
6, 1, 16,
7, 123, 33,
7, 7, 13,
7, 5, 14,
7, 6, 10,
7, 121, 19,
7, 4, 11,
7, 122, 21,
7, 120, 15,
7, 124, 34,
8, 33, 22,
8, 39, 26,
8, 252, 27,
8, 38, 20,
8, 36, 24,
8, 37, 23,
8, 253, 28,
8, 255, 52,
8, 254, 51,
8, 32, 37,
8, 35, 35,
8, 34, 36,
8, 251, 50,
8, 250, 49,
9, 5, 30,
9, 7, 31,
9, 4, 29,
10, 12, 38,
10, 13, 32,
12, 31, 44,
12, 26, 45,
12, 25, 46,
12, 23, 47,
12, 22, 48,
12, 28, 39,
12, 18, 40,
12, 21, 42,
12, 30, 41,
12, 17, 43,
13, 21, 54,
13, 20, 55,
13, 22, 53,
13, 19, 56,
13, 18, 57,
13, 17, 58,
13, 16, 59,
13, 31, 60,
13, 30, 61,
13, 29, 62,
13, 28, 63,
13, 27, 64,
14, 19, 77,
14, 30, 66,
14, 29, 67,
14, 28, 68,
14, 27, 69,
14, 26, 70,
14, 25, 71,
14, 24, 72,
14, 23, 73,
14, 22, 74,
14, 21, 75,
14, 20, 76,
14, 31, 65,
14, 18, 78,
14, 17, 79,
14, 16, 80,
15, 23, 82,
15, 22, 83,
15, 21, 84,
15, 20, 85,
15, 19, 86,
15, 18, 87,
15, 17, 88,
15, 24, 81,
15, 16, 89,
15, 31, 90,
15, 30, 91,
15, 29, 92,
15, 28, 93,
15, 27, 94,
15, 26, 95,
15, 25, 96,
16, 23, 105,
16, 18, 98,
16, 17, 99,
16, 16, 100,
16, 20, 101,
16, 26, 102,
16, 25, 103,
16, 24, 104,
16, 19, 97,
16, 22, 106,
16, 21, 107,
16, 31, 108,
16, 30, 109,
16, 29, 110,
16, 28, 111,
16, 27, 112,
0
};
*/

// RUN,LEVEL
uint8 rl_B14[][2] =
{
	-1,	-1,//End of Block	
//	0,	1,
	0,	1,
	1,	1,
	0,	2,
	2,	1,
	0,	3,
	3,	1,
	4,	1,
	1,	2,
	5,	1,
	6,	1,
	7,	1,
	0,	4,
	2,	2,
	8,	1,
	9,	1,
	-1,	0,	// Escape	
	0,	5,
	0,	6,
	1,	3,
	3,	2,
	10,	1,
	11,	1,
	12,	1,
	13,	1,
	0,	7,
	1,	4,
	2,	3,
	4,	2,
	5,	2,
	14,	1,
	15,	1,
	16,	1,

	0,	8,
	0,	9,
	0,	10,
	0,	11,
	1,	5,
	2,	4,
	3,	3,
	4,	3,
	6,	2,
	7,	2,
	8,	2,
	17,	1,
	18,	1,
	19,	1,
	20,	1,
	21,	1,
	0,	12,
	0,	13,
	0,	14,
	0,	15,
	1,	6,
	1,	7,
	2,	5,
	3,	4,
	5,	3,
	9,	2,
	10,	2,
	22,	1,
	23,	1,
	24,	1,
	25,	1,
	26,	1,

	0,	16,
	0,	17,
	0,	18,
	0,	19,
	0,	20,
	0,	21,
	0,	22,
	0,	23,
	0,	24,
	0,	25,
	0,	26,
	0,	27,
	0,	28,
	0,	29,
	0,	30,
	0,	31,
	0,	32,
	0,	33,
	0,	34,
	0,	35,
	0,	36,
	0,	37,
	0,	38,
	0,	39,
	0,	40,
	1,	8,
	1,	9,
	1,	10,
	1,	11,
	1,	12,
	1,	13,
	1,	14,

	1,	15,
	1,	16,
	1,	17,
	1,	18,
	6,	3,
	11,	2,
	12,	2,
	13,	2,
	14,	2,
	15,	2,
	16,	2,
	27,	1,
	28,	1,
	29,	1,
	30,	1,
	31,	1,
};

char* str_tab_B9[] = 
{
	"111",
	"1101",
	"1100",
	"1011",
	"1010",
	"10011",
	"10010",
	"10001",
	"10000",
	"01111",
	"01110",
	"01101",
	"01100",
	"01011",
	"01010",
	"01001",
	"01000",
	"001111",
	"001110",
	"001101",
	"001100",
	"0010111",
	"0010110",
	"0010101",
	"0010100",
	"0010011",
	"0010010",
	"0010001",
	"0010000",
	"00011111",
	"00011110",
	"00011101",

	"00011100",
	"00011011",
	"00011010",
	"00011001",
	"00011000",
	"00010111",
	"00010110",
	"00010101",
	"00010100",
	"00010011",
	"00010010",
	"00010001",
	"00010000",
	"00001111",
	"00001110",
	"00001101",
	"00001100",
	"00001011",
	"00001010",
	"00001001",
	"00001000",
	"00000111",
	"00000110",
	"00000101",
	"00000100",
	"000000111",
	"000000110",
	"000000101",
	"000000100",
	"000000011",
	"000000010",
	"000000001",

	NULL
};

vtab_byte tab_B9[512] =
{
9, 63,
9, 63,
9, 62,
9, 61,
9, 60,
9, 59,
9, 58,
9, 57,
8, 56,
8, 56,
8, 55,
8, 55,
8, 54,
8, 54,
8, 53,
8, 53,
8, 52,
8, 52,
8, 51,
8, 51,
8, 50,
8, 50,
8, 49,
8, 49,
8, 48,
8, 48,
8, 47,
8, 47,
8, 46,
8, 46,
8, 45,
8, 45,
8, 44,
8, 44,
8, 43,
8, 43,
8, 42,
8, 42,
8, 41,
8, 41,
8, 40,
8, 40,
8, 39,
8, 39,
8, 38,
8, 38,
8, 37,
8, 37,
8, 36,
8, 36,
8, 35,
8, 35,
8, 34,
8, 34,
8, 33,
8, 33,
8, 32,
8, 32,
8, 31,
8, 31,
8, 30,
8, 30,
8, 29,
8, 29,
7, 28,
7, 28,
7, 28,
7, 28,
7, 27,
7, 27,
7, 27,
7, 27,
7, 26,
7, 26,
7, 26,
7, 26,
7, 25,
7, 25,
7, 25,
7, 25,
7, 24,
7, 24,
7, 24,
7, 24,
7, 23,
7, 23,
7, 23,
7, 23,
7, 22,
7, 22,
7, 22,
7, 22,
7, 21,
7, 21,
7, 21,
7, 21,
6, 20,
6, 20,
6, 20,
6, 20,
6, 20,
6, 20,
6, 20,
6, 20,
6, 19,
6, 19,
6, 19,
6, 19,
6, 19,
6, 19,
6, 19,
6, 19,
6, 18,
6, 18,
6, 18,
6, 18,
6, 18,
6, 18,
6, 18,
6, 18,
6, 17,
6, 17,
6, 17,
6, 17,
6, 17,
6, 17,
6, 17,
6, 17,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 16,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 15,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 14,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 13,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 12,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 11,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 10,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 9,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 8,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 7,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 6,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
5, 5,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 4,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 3,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 2,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
4, 1,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
3, 0,
};

/*
vtab2 tab_B9[] = 
{
3, 7, 0,
4, 12, 2,
4, 11, 3,
4, 10, 4,
4, 13, 1,
5, 18, 6,
5, 17, 7,
5, 19, 5,
5, 16, 8,
5, 15, 9,
5, 14, 10,
5, 13, 11,
5, 12, 12,
5, 11, 13,
5, 10, 14,
5, 9, 15,
5, 8, 16,
6, 14, 18,
6, 13, 19,
6, 12, 20,
6, 15, 17,
7, 22, 22,
7, 21, 23,
7, 23, 21,
7, 20, 24,
7, 19, 25,
7, 18, 26,
7, 17, 27,
7, 16, 28,
8, 30, 30,
8, 29, 31,
8, 31, 29,
8, 28, 32,
8, 27, 33,
8, 26, 34,
8, 25, 35,
8, 24, 36,
8, 23, 37,
8, 22, 38,
8, 21, 39,
8, 20, 40,
8, 19, 41,
8, 18, 42,
8, 17, 43,
8, 16, 44,
8, 15, 45,
8, 14, 46,
8, 13, 47,
8, 12, 48,
8, 11, 49,
8, 10, 50,
8, 9, 51,
8, 8, 52,
8, 7, 53,
8, 6, 54,
8, 5, 55,
8, 4, 56,
9, 6, 58,
9, 5, 59,
9, 4, 60,
9, 3, 61,
9, 2, 62,
//9, 1, 63,	// not used for 4:2:0
9, 7, 57,
0
};
*/

int tab_Cbp[] =
{
	60,
	4,
	8,
	16,
	32,
	12,
	48,
	20,
	40,
	28,
	44,
	52,
	56,
	1,
	61,
	2,
	62,
	24,
	36,
	3,
	63,
	5,
	9,
	17,
	33,
	6,
	10,
	18,
	34,
	7,
	11,
	19,

	35,
	13,
	49,
	21,
	41,
	14,
	50,
	22,
	42,
	15,
	51,
	23,
	43,
	25,
	37,
	26,
	38,
	29,
	45,
	53,
	57,
	30,
	46,
	54,
	58,
	31,
	47,
	55,
	59,
	27,
	39,
	0,// (NOTE) This entry shall not be used with 4:2:0 chrominance structure
};

/////////////////////////////////////////
// PictureDecoder

PictureDecoder::PictureDecoder(MpegVideoSequenceFormat* sequence, BitStreamEx* file)
{
	m_sequence = sequence;
	m_file = file;

/*
In the case that the lower layer conforms to ISO/IEC 11172-2 (and not this specification) then picture_coding_extension() is not present in the lower layer and the following values shall be assumed for the decoding process:
*/
/*
f_code[0][0]	=	forward_f_code in the lower layer or 15
f_code[0][1]		=	forward_f_code in the lower layer or 15
f_code[1][0]	=	backward_f_code in the lower layer or 15
f_code[1][1]	=	backward_f_code in the lower layer or 15
*/
	m_intra_dc_precision	= 0;
	m_picture_structure = PictureStructure_Frame_picture;
	m_concealment_motion_vectors = 0;
	m_frame_pred_frame_dct = 1;
	m_q_scale_type = 0;
	m_intra_vlc_format = 0;
	m_progressive_frame = 1;
	m_repeat_first_field = 0;

	m_spatial_temporal_weight_class = 0;

	m_alternate_scan = 0;

	m_ybuf = NULL;
	m_crbuf = NULL;
	m_cbbuf = NULL;
//		m_macroblocksBuffer = NULL;
}

#if 0
ErrorCode PictureDecoder::CreateBuffers()
{
	int mb_rows = (m_sequence->m_vertical_size + 15)/16;

	m_ybuf = (uint8*)calloc(1, (m_sequence->m_mb_width*16+1)*(mb_rows*16+1));

#if 0
	if (m_file->m_chroma_format == 1)	// 4:2:0
	{
		m_crbuf = (uint8*)calloc(m_file->m_mb_width*8*mb_rows*8, 2);
		m_cbbuf = (uint8*)calloc(m_file->m_mb_width*8*mb_rows*8, 2);
	}
	else if (m_file->m_chroma_format == 2)	// 4:2:2
	{
		m_crbuf = (uint8*)calloc(m_file->m_mb_width*16*mb_rows*8, 2);
		m_cbbuf = (uint8*)calloc(m_file->m_mb_width*8*mb_rows*8, 2);
	}
	else if (m_file->m_chroma_format == 3)	// 4:4:4
	{
		m_crbuf = (uint8*)calloc(m_file->m_mb_width*16*mb_rows*16, 2);
		m_cbbuf = (uint8*)calloc(m_file->m_mb_width*16*mb_rows*16, 2);
	}
#endif

//	m_macroblocksBuffer = new CMacroBlock[m_file->m_mb_width*mb_rows];

	return S_OK;
}
#endif

ErrorCode PictureDecoder::picture_header()
{
//	ASSERT(m_file->m_next_code == 0x100);

#if 0
	m_temporal_reference = m_file->getnbits(10);
	m_picture_coding_type = m_file->getnbits(3);	// I=1, P=2, B=3
#endif

	//TRACE("temporal_reference: %d, picture_coding_type: %d\n", m_temporal_reference, m_picture_coding_type);

	int vbv_delay = m_file->getnbits(16);

	if (m_pic->m_picture_coding_type == 2 || m_pic->m_picture_coding_type == 3)	// P or B
	{
		m_full_pel[0] = m_file->getbit();
		int forward_f_code = m_file->getnbits(3);
		if (!m_sequence->m_mpeg1)	// mpeg2
		{
			ASSERT(m_full_pel[0] == 0);
			ASSERT(forward_f_code == 7);
		}
		else	// mpeg1
		{
			m_f_code[0][0] = forward_f_code;
			m_f_code[0][1] = forward_f_code;
		}
	}

	if (m_pic->m_picture_coding_type == 3)	// B
	{
		m_full_pel[1] = m_file->getbit();
		int backward_f_code = m_file->getnbits(3);
		if (!m_sequence->m_mpeg1)	// mpeg2
		{
			ASSERT(m_full_pel[1] == 0);
			ASSERT(backward_f_code == 7);
		}
		else	// mpeg1
		{
			m_f_code[1][0] = backward_f_code;
			m_f_code[1][1] = backward_f_code;
		}
	}

	while (m_file->getbit() == 1)	// extra_bit_picture
	{
		m_file->getnbits(8);	// extra_information_picture (ignore)
	}

	m_file->next_start_code();

	return Success;
}

void PictureDecoder::picture_coding_extension()
{
	if (m_file->m_next_code != 0x1b5)
	{
		TRACE("error: Expected picture_coding_extension(0x1b5), instead of (%x)", m_file->m_next_code);
		THROW(-1);
	}

	int extension_start_code_identifier = m_file->getnbits(4);
	ASSERT(extension_start_code_identifier == 0x8);

	m_f_code[0][0] = m_file->getnbits(4);	/* forward horizontal */
	m_f_code[0][1] = m_file->getnbits(4);	/* forward vertical */
	m_f_code[1][0] = m_file->getnbits(4);	/* backward horizontal */
	m_f_code[1][1] = m_file->getnbits(4);	/* backward vertical */
	m_intra_dc_precision = m_file->getnbits(2);
	m_picture_structure = m_file->getnbits(2);
	int top_field_first = m_file->getbit();
	m_frame_pred_frame_dct = m_file->getbit();
	m_concealment_motion_vectors = m_file->getbit();
	VERIFY(m_concealment_motion_vectors == 0);	// TODO, support this

	m_q_scale_type = m_file->getbit();
	m_intra_vlc_format = m_file->getbit();
	m_alternate_scan = m_file->getbit();
	m_repeat_first_field = m_file->getbit();
	int chroma_420_type = m_file->getbit();	// This flag exists for historical reasons
	m_progressive_frame  = m_file->getbit();

	if (m_sequence->m_chroma_format == 1)	// 4:2:0
	{
		VERIFY(chroma_420_type == m_progressive_frame);
	}
	else
	{
		// chroma_420_type has no meaning
	}

	int composite_display_flag = m_file->getbit();
	if (composite_display_flag)
	{
		int v_axis = m_file->getbit();
		int field_sequence = m_file->getnbits(3);
		int sub_carrier = m_file->getbit();
		int burst_amplitude = m_file->getnbits(7);
		int sub_carrier_phase = m_file->getnbits(8);
	}

	m_file->next_start_code();
}

void PictureDecoder::extension_and_user_data(int i)
{
	while ((m_file->m_next_code == 0x1b5/*extension_start_code*/) ||
			(m_file->m_next_code == 0x1b2/*user_data_start_code*/))
	{
		if (i != 1)
		{
			if (m_file->m_next_code == 0x1b5/*extension_start_code*/)
				extension_data(i);
		}

		if (m_file->m_next_code == 0x1b2/*user_data_start_code*/)
		{
			while (m_file->looknbits(24) != 0x1)
			{
				m_file->skipnbits(8);
			}
			m_file->next_start_code();
		}
	}
}

void PictureDecoder::extension_data(int i)
{
	while (m_file->m_next_code == 0x1b5)
	{
		if (i == 0)	/* follows sequence_extension() */
		{
			// ....
		}

	/* Note: extension never follows a group_of_pictures_header() */
		if (i == 2)	/* follows picture_coding_extension() */
		{
			if (m_file->getnbits(4) == 0x3/*"Quant Matrix Extension ID"*/)
				quant_matrix_extension();
			else
				m_file->ungetbits(4);

			if (m_file->getnbits(4) == 0x7/*"Picture Pan Scan Extension ID"*/)
				ASSERT(0);//picture_display_extension();
			else
				m_file->ungetbits(4);

			if	(m_file->getnbits(4) == 0x9/*"Picture Spatial Scalable Extension ID"*/)
				ASSERT(0);//picture_spatial_scalable_extension();
			else
				m_file->ungetbits(4);

			if (m_file->getnbits(4) == 0xa/*"Picture Temporal Scalable Ext. ID"*/)
				ASSERT(0);//picture_temporal_scalable_extension();
			else
				m_file->ungetbits(4);
		}

	//	align();
	//	m_next_code = getnbits(32);
	}
}

void PictureDecoder::quant_matrix_extension()
{
//	extension_start_code_identifier	4 (already read)

	int load_intra_quantiser_matrix = m_file->getbit();
	if (load_intra_quantiser_matrix)
	{
		//uint8 intra_quantiser_matrix[64];

		for (int i = 0; i < 64; i++)
		{
			m_sequence->m_intra_quantiser_matrix[i] = m_file->getnbits(8);
		}
	}

	int load_non_intra_quantiser_matrix	= m_file->getbit();
	if (load_non_intra_quantiser_matrix)
	{
		//uint8 non_intra_quantiser_matrix[64];
		for (int i = 0; i < 64; i++)
		{
			m_sequence->m_non_intra_quantiser_matrix[i] = m_file->getnbits(8);
		}
	}

	int load_chroma_intra_quantiser_matrix	= m_file->getbit();
	if (load_chroma_intra_quantiser_matrix)
	{
		//uint8 chroma_intra_quantiser_matrix[64];
		for (int i = 0; i < 64; i++)
		{
			m_sequence->m_chroma_intra_quantiser_matrix[i] = m_file->getnbits(8);
		}
	}

	int load_chroma_non_intra_quantiser_matrix = m_file->getbit();
	if (load_chroma_non_intra_quantiser_matrix)
	{
	//	uint8 chroma_non_intra_quantiser_matrix[64];
		for (int i = 0; i < 64; i++)
		{
			m_sequence->m_chroma_non_intra_quantiser_matrix[i] = m_file->getnbits(8);
		}
	}

	m_file->next_start_code();
}

void PictureDecoder::picture_data()
{
	m_pRefPic[0] = NULL;
	m_pRefPic[1] = NULL;

	if (m_pic->m_picture_coding_type != 1)	// P and B Picture
	{
		PictureDecoder* pRefPic;
		list<PictureDecoder*, System::__gc_allocator>::iterator pos = m_pos;
		while (pos != m_sequence->m_groupPictures.begin())
		{
			//m_sequence->m_groupPictures.GetPrev(pos);
			--pos;

			//if (pos == NULL) break;
			if (pos == m_sequence->m_groupPictures.end()) break;

			pRefPic = *pos;//(PictureDecoder*)m_sequence->m_groupPictures.GetAt(pos);

			if (pRefPic->m_pic->m_temporal_reference_abs < m_pic->m_temporal_reference_abs &&
				pRefPic->m_pic->m_picture_coding_type < 3)
			{
				m_pRefPic[0] = pRefPic;
				break;
			}
		}
	}

	if (m_pic->m_picture_coding_type == 3)	// B-Picture
	{
		PictureDecoder* pRefPic;
		list<PictureDecoder*, System::__gc_allocator>::iterator pos = m_pos;
		while (pos != m_sequence->m_groupPictures.begin())
		{
			--pos;//m_sequence->m_groupPictures.GetPrev(pos);
			if (pos == m_sequence->m_groupPictures.end())
			{
				TRACE("error: no reference picture");
				THROW(-1);
			}
			pRefPic = *pos;//(PictureDecoder*)m_sequence->m_groupPictures.GetAt(pos);

			if (pRefPic->m_pic->m_temporal_reference_abs > m_pic->m_temporal_reference_abs &&
				pRefPic->m_pic->m_picture_coding_type < 3)
			{
				m_pRefPic[1] = pRefPic;
				break;
			}
		}
	}

// TODO, once I met picture_coding extension here

// Do all slices
	if (m_file->m_next_code < 0x101 || m_file->m_next_code > 0x1af)
		THROW(-1);

//	ASSERT(m_file->m_next_code >= 0x101 && m_file->m_next_code <= 0x1af);

	while (m_file->m_next_code >= 0x101 && m_file->m_next_code <= 0x1af)	// slice start code
	{
		slice(m_file->m_next_code);

		m_file->next_start_code();
	}
}

void PictureDecoder::slice(int next_code)
{
	int slice_vertical_position = next_code & 0xff;	// Is this correctly last 8 bits ?

// the vertical position in macroblock units of the first macroblock in the slice

	if (m_sequence->m_vertical_size > 2800)
	{
		int slice_vertical_position_extension = m_file->getnbits(3);
		m_mb_row = (slice_vertical_position_extension << 7) + slice_vertical_position - 1;
	}
	else
	{
		m_mb_row = slice_vertical_position - 1;
	}

// At the start of a slice previous_macroblock_address is reset as follows
	m_previous_macroblock_address = (m_mb_row * m_sequence->m_mb_width) -1;

	/*
The predictors shall be reset to the reset value at the following times:
o	At the start of a slice.
o	Whenever a non-intra macroblock is decoded.
o	Whenever a macroblock is skipped. i.e. when macroblock_address_increment > 1.
*/
	m_dc_dct_pred[0] = intra_dc_reset[m_intra_dc_precision];
	m_dc_dct_pred[1] = intra_dc_reset[m_intra_dc_precision];
	m_dc_dct_pred[2] = intra_dc_reset[m_intra_dc_precision];

// All motion vector predictors shall be reset to zero at start of slice
	m_PMV[0][0][0] = 0;
	m_PMV[0][0][1] = 0;
	m_PMV[0][1][0] = 0;
	m_PMV[0][1][1] = 0;
	m_PMV[1][0][0] = 0;
	m_PMV[1][0][1] = 0;
	m_PMV[1][1][0] = 0;
	m_PMV[1][1][1] = 0;

	if (false/* <sequence_scalable_extension() is present in the bitstream>*/ )
	{
		if (false/*scalable_mode == "data partitioning"*/ )
		{
			int priority_breakpoint = m_file->getnbits(7);
		}
	}

	m_quantiser_scale_code = m_file->getnbits(5);
	ASSERT(m_quantiser_scale_code != 0);
	if (m_quantiser_scale_code == 0)
		THROW(-1);

// MPEG 1
	while (m_file->getbit() == 1)
	{
		int extra_information_slice = m_file->getnbits(8);
	}

//	int extra_bit_slice = getnbits(1);
//	ATLASSERT(extra_bit_slice == 0);

	/* MPEG2?
	if (getnbits(1) == 1)	// intra_slice_flag
	{
		//int intra_slice_flag = getnbits(1);
		int intra_slice = getnbits(1);
		int reserved_bits = getnbits(7);

		while (getnbits(1) == 1)
		{
			getnbits(8);	// extra_information_slice (ignore)
		}
	}
	*/

	int count = 0;
	do
	{
		macroblock();
		count++;

		if (m_file->checknbits_zero(23))
		{
			break;
		}
	}
	while (1);
}

void PictureDecoder::macroblock()
{
	int macroblock_address_increment = 0;

	while (1)
	{
		int index = getvariablebits(m_file, tab_B1, 11);
		if (index == 33)
		{
			macroblock_address_increment += 33;
			continue;
		}
		macroblock_address_increment += index+1;
		break;
	}

#ifdef _DEBUG
	if (m_pic->m_picture_coding_type == 1)	// I-picture
	{
		//ATLASSERT(macroblock_address_increment == 1);
	}
#endif

	m_macroblock_address = m_previous_macroblock_address + macroblock_address_increment;	// TODO

	if (true)
	{
		if (m_pic->m_picture_coding_type == 2)	// P-picture
		{
			if (macroblock_address_increment > 1)	// Skipped macroblock
			{
			// All motion vector predictors shall be reset to zero In a P-picture when a macroblock is skipped
				m_PMV[0][0][0] = 0;
				m_PMV[0][0][1] = 0;
				m_PMV[0][1][0] = 0;
				m_PMV[0][1][1] = 0;
				m_PMV[1][0][0] = 0;
				m_PMV[1][0][1] = 0;
				m_PMV[1][1][0] = 0;
				m_PMV[1][1][1] = 0;
			}
		}

		if (macroblock_address_increment > 1)	// Skipped macroblock
		{
			//ASSERT(m_pic->m_picture_coding_type != 1);

			if (m_pic->m_picture_coding_type == 1)
			{
				TRACE("warning: skipped macroblock in intra frame\n");
			}
			m_macroblock_intra = 0;	// Skipped P-B are never intra
		}

	// Process skipped macroblocks
		for (int macroblock_address = m_previous_macroblock_address+1; macroblock_address < m_macroblock_address; macroblock_address++)
		{
			macroblock2(macroblock_address);
		}
	}

	m_previous_macroblock_address = m_macroblock_address;

	macroblock_modes();	// macroblock_type among other things

//	CMacroBlock* pMacroBlock = &m_macroblocksBuffer[m_mb_row*m_file->m_mb_width + m_mb_column];

// Reset Whenever an intra macroblock is decoded which has no concealment motion vectors. 
	if (m_macroblock_intra == 1 && m_concealment_motion_vectors == 0)
	{
		m_PMV[0][0][0] = 0;
		m_PMV[0][0][1] = 0;
		m_PMV[0][1][0] = 0;
		m_PMV[0][1][1] = 0;
		m_PMV[1][0][0] = 0;
		m_PMV[1][0][1] = 0;
		m_PMV[1][1][0] = 0;
		m_PMV[1][1][1] = 0;
	}

	/*
The predictors shall be reset to the reset value at the following times:
o	At the start of a slice.
o	Whenever a non-intra macroblock is decoded.
o	Whenever a macroblock is skipped. i.e. when macroblock_address_increment > 1.
*/
	if (m_macroblock_intra == 0 || macroblock_address_increment > 1)
	{
		m_dc_dct_pred[0] = intra_dc_reset[m_intra_dc_precision];
		m_dc_dct_pred[1] = intra_dc_reset[m_intra_dc_precision];
		m_dc_dct_pred[2] = intra_dc_reset[m_intra_dc_precision];
	}

	if (m_macroblock_quant)
	{
		m_quantiser_scale_code = m_file->getnbits(5);
		if (m_quantiser_scale_code == 0)
			THROW(-1);
	}

	if (m_macroblock_motion_forward ||
		(m_macroblock_intra && m_concealment_motion_vectors))
	{
		motion_vectors(0);
	}

	if (m_macroblock_motion_backward)
	{
		motion_vectors(1);
	}

	if (m_macroblock_intra && m_concealment_motion_vectors)
	{
		m_file->getmarkerbit();
	}

	// TODO, improve performance here
	{
		for (int i = 0; i < 12; i++)
		{
			if (m_macroblock_intra != 0)
				m_pattern_code[i] = 1;
			else
				m_pattern_code[i] = 0;
		}
	}

	if (m_macroblock_pattern)
	{
	// 6.3.16.3	Coded block pattern
		int cbp = coded_block_pattern();

		if (m_macroblock_intra == 0)
		{
			int i;

			for (i = 0; i < 6; i++)
			{
				if (cbp & (1<<(5-i)))
			//	if (cbp & (1<<(i)))
					m_pattern_code[i] = 1;
			}

#if 0
			if (m_chroma_format == 2)
			{
				for (i = 6; i < 8; i++)
				{
					if (m_coded_block_pattern_1 & (1<<(7-i)))
						m_pattern_code[i] = 1;
				}
			}
			else if (m_chroma_format == 3)
			{
				for (i = 6; i < 12; i++)
				{
					if (m_coded_block_pattern_2 & (1<<(11-i)))
						m_pattern_code[i] = 1;
				}
			}
#endif
		}
	}

	if (true)
	{
		macroblock2(m_macroblock_address);
	}
	else
	{
		for (int i = 0; i < 6/*block_count*/; i++)
		{
			short QFS[8*8];
			block(i, QFS);
		}
	}
}

uint8 ref_clip(uint8* pel_ref, int rowbytes, int y, int x)
{
	if (x < 0)
		x = 0;
	else if (x > 352-1)
		x = 352-1;

	if (y < 0)
		y = 0;

	return pel_ref[(y)*rowbytes + x];
}

void PictureDecoder::ComputeMotionVector(int r, int s, int t, int vector_[2][2][2])
{
	int r_size = m_f_code[s][t] - 1;
	int f = 1 << r_size;
	int high = ( 16 * f ) -  1;
	int low = ( (-16) * f );
	int range = ( 32 * f );

	int delta;

	if ((f == 1) || (m_motion_code[r][s][t] == 0))
	{
		delta = m_motion_code[r][s][t];
	}
	else
	{
		delta = ((abs(m_motion_code[r][s][t]) - 1 ) * f ) + m_motion_residual[r][s][t] + 1;
		if (m_motion_code[r][s][t] < 0)
			delta = -delta;
	}

	int prediction = m_PMV[r][s][t];
	if ((m_mv_format == field) && (t==1) && (m_picture_structure == PictureStructure_Frame_picture))
		prediction = m_PMV[r][s][t] / 2;	// TODO DIV

	vector_[r][s][t] = prediction + delta;

	if (m_full_pel[s])
		vector_[r][s][t] <<= 1;

	if (vector_[r][s][t] < low)
		vector_[r][s][t] = vector_[r][s][t] + range;

	if (vector_[r][s][t] > high)
		vector_[r][s][t] = vector_[r][s][t] - range;

	if ((m_mv_format == field) && (t == 1) && (m_picture_structure == PictureStructure_Frame_picture))
		m_PMV[r][s][t] = vector_[r][s][t] * 2;
	else
		m_PMV[r][s][t] = vector_[r][s][t];
}

void PictureDecoder::macroblock2(int macroblock_address)
{
	m_mb_row = macroblock_address / m_sequence->m_mb_width;

	int mb_rows = (m_sequence->m_vertical_size + 15)/16;
	ASSERT(m_mb_row < mb_rows);

	m_mb_column = macroblock_address % m_sequence->m_mb_width;
	ASSERT(m_mb_column < m_sequence->m_mb_width);

	int block_count;
	if (m_sequence->m_chroma_format == 1)	//	4:2:0
		block_count = 6;
	else if (m_sequence->m_chroma_format == 2)	//	4:2:2
		block_count = 8;
	else if (m_sequence->m_chroma_format == 3)	//	4:4:4
		block_count = 12;

	uint8 pel_pred[12][8][8];// = {0};	// is the prediction sample being formed 
	// TODO, make this point directly to dest buffer

	if (!m_macroblock_intra && m_pic->m_picture_coding_type > 1)	// TODO, check for presence of motion vectors instead?
	{
		//if (cc == 0)	// luminance

		//int i = 0;	// ??

		int s0, s1;

		if (m_macroblock_motion_forward)
			s0 = 0;
		else
			s0 = 1;

		if (m_macroblock_motion_backward)
			s1 = 1;
		else
			s1 = 0;

		int vector[2][2][2];

		if (m_pic->m_picture_coding_type == 3)
		{
			if (m_macroblock_intra)
			{
				m_PMV[0][0][0] = 0;
				m_PMV[0][0][1] = 0;
				m_PMV[0][1][0] = 0;
				m_PMV[0][1][1] = 0;
				m_PMV[1][0][0] = 0;
				m_PMV[1][0][1] = 0;
				m_PMV[1][1][0] = 0;
				m_PMV[1][1][1] = 0;
			}
		}

		if (m_pic->m_picture_coding_type == 2 && m_macroblock_address != macroblock_address)
		{
			for (int r = 0; r < 1; r++)
			{
				for (int s = 0; s < 2; s++)	// TODO < 1 (only forward used)
				{
					vector[r][s][0] = 0;//vector_[r][s][t];	//	(for all r, s and t)
					vector[r][s][1] = 0;//vector_[r][s][t];	//	(for all r, s and t)
				}
			}

			s0 = 0;

		//	if (m_picture_coding_type == 
		// PVM are reset to zero earlier
			m_PMV[0][0][0] = 0;
			m_PMV[0][0][1] = 0;
			m_PMV[0][1][0] = 0;
			m_PMV[0][1][1] = 0;
			m_PMV[1][0][0] = 0;
			m_PMV[1][0][1] = 0;
			m_PMV[1][1][0] = 0;
			m_PMV[1][1][1] = 0;
		}
		else if (m_pic->m_picture_coding_type == 3 && m_macroblock_address != macroblock_address)
		{
			for (int r = 0; r < 1; r++)
			{
				vector[r][0][0] = m_PMV[r][0][0];
				vector[r][0][1] = m_PMV[r][0][1];

				vector[r][1][0] = m_PMV[r][1][0];
				vector[r][1][1] = m_PMV[r][1][1];
			}
		}
		else
		{
		//	int vector_[2][2][2];
			{
				if (m_macroblock_motion_forward)
				{
					ComputeMotionVector(0, 0, 0, vector);
					ComputeMotionVector(0, 0, 1, vector);
				}
				else if (m_pic->m_picture_coding_type == PictureType_P)
				{
					m_PMV[0][0][0] = 0;
					m_PMV[0][0][1] = 0;
					vector[0][0][0] = 0;
					vector[0][0][1] = 0;

					s0 = 0;	// TODO, hack
				}
				else if (m_pic->m_picture_coding_type == PictureType_B)
				{
					vector[0][0][0] = m_PMV[0][0][0];
					vector[0][0][1] = m_PMV[0][0][1];
				}

				if (m_macroblock_motion_backward)
				{
					ComputeMotionVector(0, 1, 0, vector);
					ComputeMotionVector(0, 1, 1, vector);
				}
				else if (m_pic->m_picture_coding_type == PictureType_P)
				{
					m_PMV[0][1][0] = 0;
					m_PMV[0][1][1] = 0;
					vector[0][1][0] = 0;
					vector[0][1][1] = 0;
				}
				else if (m_pic->m_picture_coding_type == PictureType_B)
				{
					;//MessageBeep(-1);
					//s1 = 1;	// TODO, hack
					vector[0][1][0] = m_PMV[0][1][0];
					vector[0][1][1] = m_PMV[0][1][1];
				}
			}

			/*
// The motion vectors calculated in the previous clauses refer to the luminance component where;
			{
				for (int r = 0; r < 1; r++)
				{
					for (int s = 0; s < 2; s++)
					{
						vector[r][s][0] = vector_[r][s][0];	//	(for all r, s and t)
						vector[r][s][1] = vector_[r][s][1];	//	(for all r, s and t)
					}
//For each of the two chrominance components the motion vectors shall be scaled as follows:
//.....
				}
			}
			*/
		}

		uint8 pel_preds[2][12][8][8];// = {0};	// is the prediction sample being formed 

			/*
		if (s1-s0 < 0)
		{
			MessageBeep(-1);
		}
		*/

		for (int s = s0; s <= s1; s++)	// ??
		{
			for (int i = 0; i < 6; i++)
			{
				int int_vec[2];
				uint8 half_flag[2];

	// For each prediction block the integer sample motion vectors int_vec[t] and the half sample flags half_flag[t] shall be formed as follows;
				for (int r = 0; r < 1; r++)	// ??
				{
					int_vec[0] = vector[r][s][0]>>1;
					if (i >= 4) int_vec[0] >>= 1;
					half_flag[0] = vector[r][s][0] & 1;

					int_vec[1] = vector[r][s][1]>>1;
					if (i >= 4) int_vec[1] >>= 1;
					half_flag[1] = vector[r][s][1] & 1;
				}

				PictureDecoder* pRefPic = m_pRefPic[s];
				if (pRefPic == NULL)
				{
					TRACE("error: pRefPic = NULL\n");
					THROW(-1);
				}

				uint8* pel_ref;
				int bx;
				int by;
				int rowbytes;

				if (i < 4)
				{
					int nrow = i >> 1;
					int ncol = i & 1;

					by = m_mb_row*16 + nrow*8;
					bx = m_mb_column*16 + ncol*8;
					rowbytes = m_sequence->m_mb_width*16;

					pel_ref = pRefPic->m_ybuf;
				}
				else if (i == 4)
				{
					by = m_mb_row*8;
					bx = m_mb_column*8;
					rowbytes = m_sequence->m_mb_width*8;
					pel_ref = pRefPic->m_crbuf;
				}
				else
				{
					by = m_mb_row*8;
					bx = m_mb_column*8;
					rowbytes = m_sequence->m_mb_width*8;
					pel_ref = pRefPic->m_cbbuf;
				}

				if (!half_flag[0])
				{
					if (!half_flag[1])
					{
						if (bx + int_vec[0] < 0)
						{
							THROW(-1);
						}

						if (by + int_vec[1] < 0)
						{
							THROW(-1);
						}

						for (int iy = 0; iy < 8; iy++)
						{
							int y = by + iy;
							uint8* dst = pel_preds[s][i][iy];
							uint8* src = &pel_ref[(y + int_vec[1])*rowbytes + (bx + int_vec[0])];

							// 8 bytes is 2 dwords
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							*dst++ = *src++;
							/*
							((DWORD*)dst)[0] = ((DWORD*)src)[0];
							((DWORD*)dst)[1] = ((DWORD*)src)[1];
							*/
						}
					}
					else
					{
						if (by + int_vec[1] < 0)
						{
							THROW(-1);
						}

						for (int iy = 0; iy < 8; iy++)
						{
							int y = by + iy;
							uint8* dst = pel_preds[s][i][iy];
							uint8* src[2];
							src[0] = &pel_ref[(y + int_vec[1])*rowbytes + (bx + int_vec[0])];
							src[1] = &pel_ref[(y + int_vec[1]+1)*rowbytes + (bx + int_vec[0])];

							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							*dst++ = (*src[0]++ + *src[1]++) / 2;
							/*
							for (int ix = 0; ix < 8; ix++)
							{
								int x = bx + ix;
								*dst++ = (pel_ref[(y + int_vec[1])*rowbytes + (x + int_vec[0])] +
												pel_ref[( y + int_vec[1]+1)*rowbytes + (x + int_vec[0])] ) / 2;	// TODO //
							}
							*/
						}
					}
				}
				else
				{
					if (!half_flag[1])
					{
						for (int iy = 0; iy < 8; iy++)
						{
							int y = by + iy;
							uint8* dst = pel_preds[s][i][iy];
							uint8* src = &pel_ref[(y + int_vec[1])*rowbytes + (bx + int_vec[0])];

							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							*dst++ = ((int)src[0] + src[1]) / 2; src += 1;
							//	int x = bx + ix;
							//	*dst++ = (pel_ref[(y + int_vec[1])*rowbytes + (x + int_vec[0])] +
							//										pel_ref[(y + int_vec[1])*rowbytes + (x + int_vec[0]+1)] ) / 2;	// TODO //*/
						}
					}
					else
					{
						if (by + int_vec[1] < 0)
						{
							THROW(-1);
						}

						for (int iy = 0; iy < 8; iy++)
						{
							int y = by + iy;
							uint8* dst = pel_preds[s][i][iy];

							uint8* src[2];
							src[0] = &pel_ref[(y + int_vec[1])*rowbytes + (bx + int_vec[0])];
							src[1] = &pel_ref[(y + int_vec[1]+1)*rowbytes + (bx + int_vec[0])];

						//	int x = bx + ix;
						//	ASSERT(x + int_vec[0]+1 < rowbytes);
						//	ASSERT(y + int_vec[1]+1 < m_sequence->m_vertical_size);

							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;
							*dst++ = (src[0][0] + src[0][1] + src[1][0] + src[1][1]) / 4; src[0]++; src[1]++;

								/*
								*dst++ = (pel_ref[rowbytes * (y + int_vec[1]) + (x + int_vec[0])] +
																	pel_ref[rowbytes * (y + int_vec[1]) + (x + int_vec[0]+1)] +
																	pel_ref[rowbytes * (y + int_vec[1]+1) + (x + int_vec[0])] +
																	pel_ref[rowbytes * (y + int_vec[1]+1) + (x + int_vec[0]+1)]) / 4;	// TODO //	*/
						}
					}
				}
			}
		}

		if (m_pic->m_picture_coding_type == PictureType_P)
		{
			for (int i = 0; i < 6; i++)
			{
				for (int y = 0; y < 8; y++)
				{
					pel_pred[i][y][0] = pel_preds[0][i][y][0];
					pel_pred[i][y][1] = pel_preds[0][i][y][1];
					pel_pred[i][y][2] = pel_preds[0][i][y][2];
					pel_pred[i][y][3] = pel_preds[0][i][y][3];
					pel_pred[i][y][4] = pel_preds[0][i][y][4];
					pel_pred[i][y][5] = pel_preds[0][i][y][5];
					pel_pred[i][y][6] = pel_preds[0][i][y][6];
					pel_pred[i][y][7] = pel_preds[0][i][y][7];
				}
			}
		}
		else	// PictureType_B
		{
			// Average forward backwards
			for (int i = 0; i < 6; i++)
			{
				if (m_macroblock_motion_forward && m_macroblock_motion_backward)
				{
					for (int y = 0; y < 8; y++)
					{
						pel_pred[i][y][0] = (pel_preds[0][i][y][0] + pel_preds[1][i][y][0]) / 2;
						pel_pred[i][y][1] = (pel_preds[0][i][y][1] + pel_preds[1][i][y][1]) / 2;
						pel_pred[i][y][2] = (pel_preds[0][i][y][2] + pel_preds[1][i][y][2]) / 2;
						pel_pred[i][y][3] = (pel_preds[0][i][y][3] + pel_preds[1][i][y][3]) / 2;
						pel_pred[i][y][4] = (pel_preds[0][i][y][4] + pel_preds[1][i][y][4]) / 2;
						pel_pred[i][y][5] = (pel_preds[0][i][y][5] + pel_preds[1][i][y][5]) / 2;
						pel_pred[i][y][6] = (pel_preds[0][i][y][6] + pel_preds[1][i][y][6]) / 2;
						pel_pred[i][y][7] = (pel_preds[0][i][y][7] + pel_preds[1][i][y][7]) / 2;
					}
				}
				else if (m_macroblock_motion_forward)
				{
					for (int y = 0; y < 8; y++)
					{
						pel_pred[i][y][0] = pel_preds[0][i][y][0];
						pel_pred[i][y][1] = pel_preds[0][i][y][1];
						pel_pred[i][y][2] = pel_preds[0][i][y][2];
						pel_pred[i][y][3] = pel_preds[0][i][y][3];
						pel_pred[i][y][4] = pel_preds[0][i][y][4];
						pel_pred[i][y][5] = pel_preds[0][i][y][5];
						pel_pred[i][y][6] = pel_preds[0][i][y][6];
						pel_pred[i][y][7] = pel_preds[0][i][y][7];
					}
				}
				else if (m_macroblock_motion_backward)
				{
					for (int y = 0; y < 8; y++)
					{
						pel_pred[i][y][0] = pel_preds[1][i][y][0];
						pel_pred[i][y][1] = pel_preds[1][i][y][1];
						pel_pred[i][y][2] = pel_preds[1][i][y][2];
						pel_pred[i][y][3] = pel_preds[1][i][y][3];
						pel_pred[i][y][4] = pel_preds[1][i][y][4];
						pel_pred[i][y][5] = pel_preds[1][i][y][5];
						pel_pred[i][y][6] = pel_preds[1][i][y][6];
						pel_pred[i][y][7] = pel_preds[1][i][y][7];
					}
				}
				else
				{
					for (int y = 0; y < 8; y++)
					{
						pel_pred[i][y][0] = 0;
						pel_pred[i][y][1] = 0;
						pel_pred[i][y][2] = 0;
						pel_pred[i][y][3] = 0;
						pel_pred[i][y][4] = 0;
						pel_pred[i][y][5] = 0;
						pel_pred[i][y][6] = 0;
						pel_pred[i][y][7] = 0;
					}
				}
			}
		}
	}
	else
	{
		ASSERT(m_macroblock_motion_forward == 0 && m_macroblock_motion_backward == 0);

		for (int i = 0; i < 6; i++)
		{
			for (int y = 0; y < 8; y++)
			{
				pel_pred[i][y][0] = 0;
				pel_pred[i][y][1] = 0;
				pel_pred[i][y][2] = 0;
				pel_pred[i][y][3] = 0;
				pel_pred[i][y][4] = 0;
				pel_pred[i][y][5] = 0;
				pel_pred[i][y][6] = 0;
				pel_pred[i][y][7] = 0;
			}
		}

	// Reset Whenever an intra macroblock is decoded which has no concealment motion vectors. 
	// TODO on the concealment part
		{
			m_PMV[0][0][0] = 0;
			m_PMV[0][0][1] = 0;
			m_PMV[0][1][0] = 0;
			m_PMV[0][1][1] = 0;
			m_PMV[1][0][0] = 0;
			m_PMV[1][0][1] = 0;
			m_PMV[1][1][0] = 0;
			m_PMV[1][1][1] = 0;
		}
	}

	for (int i = 0; i < block_count; i++)
	{
		int cc = cctab[i][m_sequence->m_chroma_format-1];

		if (m_macroblock_address != macroblock_address)	// Skipped macroblock
		{
		}
		else
		{
			if (m_pattern_code[i])
			{
				short QFS[64];
				block(i, QFS);

				decode_block(i, QFS);

				short* f = QFS;
				idct(f);

				for (int y = 0; y < 8; y++)
				{
					uint8* dest = pel_pred[i][y];
					short* pf = &f[y*8];

					for (int x = 0; x < 8; x++)
					{
						int k = *dest + *pf;
						if (k < 0) k = 0;
						else if (k > 255) k = 255;

						*dest = k;
						dest++;
						pf++;
					}
				}
			}
		}

		if (cc == 0)	// luminance
		{
			int nrow = i>>1;
			int ncol = i&1;

			// 4 bytes at a time
			uint32* src = (uint32*)pel_pred[i][0];
			uint32* dst = (uint32*)&m_ybuf[(m_mb_row*m_sequence->m_mb_width*16*16 + m_mb_column*16) + (nrow*8*m_sequence->m_mb_width*16 + ncol*8)/* + (y*m_sequence->m_mb_width*16)*/];
			int n = m_sequence->m_mb_width*4-2;

			// 4*2 to cover width 8 macroblock (and 8 times to cover height 8 macroblock)
			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;
		}
		else if (cc == 1)
		{
			uint32* src = (uint32*)pel_pred[i][0];
			uint32* dst = (uint32*)&m_crbuf[(m_mb_row*m_sequence->m_mb_width*8*8 + m_mb_column*8)/* + (y*m_sequence->m_mb_width*8)*/];
			int n = m_sequence->m_mb_width*2-2;

			/*
			for (int y = 0; y < 8; y++)
			{
				*dst++ = *src++;
				*dst++ = *src++;
				dst += m_sequence->m_mb_width*2-2;
			}
			*/

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;
		}
		else
		{
			uint32* src = (uint32*)pel_pred[i][0];
			uint32* dst = (uint32*)&m_cbbuf[(m_mb_row*m_sequence->m_mb_width*8*8 + m_mb_column*8)/* + (y*m_sequence->m_mb_width*8)*/];
			int n = m_sequence->m_mb_width*2-2;

			/*
			for (int y = 0; y < 8; y++)
			{
				*dst++ = *src++;
				*dst++ = *src++;
				dst += m_sequence->m_mb_width*2-2;
			}
			*/

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;

			*dst++ = *src++;
			*dst++ = *src++;
			dst += n;
		}
	}
}

void PictureDecoder::macroblock_modes()
{
	if (m_pic->m_picture_coding_type == 1)	// I-picture
	{
		if (m_file->getbit() == 1)
		{
			m_macroblock_type = 0;

			m_macroblock_quant = 0;
		}
		else
		{
			int bit = m_file->getbit();
		//	ASSERT(bit == 1);
			if (bit == 0)
			{
				TRACE("warning: macroblock_modes() unexpected 1 bit\n");
			}
			m_macroblock_type = 1;

			m_macroblock_quant = 1;
		}

		m_macroblock_motion_forward = 0;
		m_macroblock_motion_backward = 0;
		m_macroblock_intra = 1;
		m_macroblock_pattern = 0;
		m_spatial_temporal_weight_code_flag = 0;
	}
	else if (m_pic->m_picture_coding_type == 2)	// P-picture
	{
		static bool tab_macroblock_quant_P[] =
		{
			0,
			0,
			0,
			0,
			1,
			1,
			1,
		};

		static bool tab_macroblock_motion_forward_P[] =
		{
			1,
			0,
			1,
			0,
			1,
			0,
			0,
		};

		static bool tab_macroblock_pattern_P[] =
		{
			1,
			1,
			0,
			0,
			1,
			1,
			0,
		};

		static bool tab_macroblock_intra_P[] =
		{
			0,
			0,
			0,
			1,
			0,
			0,
			1,
		};

		m_macroblock_type = getvariablebits(m_file, macroblock_types_P, 6);

		m_macroblock_quant = tab_macroblock_quant_P[m_macroblock_type];
		m_macroblock_motion_forward = tab_macroblock_motion_forward_P[m_macroblock_type];
		m_macroblock_motion_backward = 0;
		m_macroblock_pattern = tab_macroblock_pattern_P[m_macroblock_type];
		m_macroblock_intra = tab_macroblock_intra_P[m_macroblock_type];
		m_spatial_temporal_weight_code_flag = 0;
	}
	else if (m_pic->m_picture_coding_type == 3)	// B-picture
	{
		static bool tab_macroblock_quant_B[] =
		{
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			1,
			1,
			1,
			1,
		};

		static bool tab_macroblock_motion_forward_B[] =
		{
			1,
			1,
			0,
			0,
			1,
			1,
			0,
			1,
			1,
			0,
			0,
		};

		static bool tab_macroblock_motion_backward_B[] =
		{
			1,
			1,
			1,
			1,
			0,
			0,
			0,
			1,
			0,
			1,
			0,
		};

		static bool tab_macroblock_pattern_B[] =
		{
			0,
			1,
			0,
			1,
			0,
			1,
			0,
			1,
			1,
			1,
			0,
		};

		static bool tab_macroblock_intra_B[] =
		{
			0,
			0,
			0,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1,
		};

		m_macroblock_type = getvariablebits(m_file, macroblock_types_B, 6);

		m_macroblock_quant = tab_macroblock_quant_B[m_macroblock_type];
		m_macroblock_motion_forward = tab_macroblock_motion_forward_B[m_macroblock_type];
		m_macroblock_motion_backward = tab_macroblock_motion_backward_B[m_macroblock_type];
		m_macroblock_pattern = tab_macroblock_pattern_B[m_macroblock_type];
		m_macroblock_intra = tab_macroblock_intra_B[m_macroblock_type];
		m_spatial_temporal_weight_code_flag = 0;
	}
	else
		ASSERT(0);

	if ( (m_spatial_temporal_weight_code_flag == 1) &&
		( true/*spatial_temporal_weight_code_table_index != '00'*/) )
	{
		ASSERT(0);
		int spatial_temporal_weight_code = m_file->getnbits(2);
	}

	m_frame_motion_type = 2;	// Assume Frame-based prediction (?)

	if (m_macroblock_motion_forward ||
		m_macroblock_motion_backward)
	{
		if (m_picture_structure == PictureStructure_Frame_picture)
		{
			if (m_frame_pred_frame_dct == 0)
			{
				m_frame_motion_type = m_file->getnbits(2);
			}
			else
			{
				m_frame_motion_type = 2;	// Assume Frame-based prediction
			}
			//else
			//	ATLASSERT(0);
		}
		else
		{
			ASSERT(0);
			m_field_motion_type = m_file->getnbits(2);
		}
	}

	// MPEG2 ???
	if (!m_sequence->m_mpeg1)
	{
		bool decode_dct_type;

		if ((m_picture_structure == PictureStructure_Frame_picture) &&
			(m_frame_pred_frame_dct == 0) &&
			(m_macroblock_intra || m_macroblock_pattern))
		{
			decode_dct_type = 1;
		}
		else
		{
			decode_dct_type = 0;
		}

		if (decode_dct_type)
		{
			int dct_type = m_file->getbit();
		}
	}
}

/*
	7.6.3.1	Decoding the motion vectors
	Each motion vector component, vector'[r][s][t], shall be calculated by any process that is equivalent to the following one.  Note that the motion vector predictors shall also be updated by this process.
*/

void PictureDecoder::motion_vectors(int s)
{
// Table 6-17 Meaning of frame_motion_type

	int motion_vector_count;

	if (m_picture_structure == PictureStructure_Frame_picture)
	{
		if (m_frame_motion_type == 1 && (m_spatial_temporal_weight_class == 0 || m_spatial_temporal_weight_class == 1))
			motion_vector_count = 2;
		else
			motion_vector_count = 1;

		if (m_frame_motion_type == 2)
			m_mv_format = frame;
		else
			m_mv_format = field;

		if (m_frame_motion_type == 3)
			m_dmv = 1;
		else
			m_dmv = 0;
	}
	else	// Field
	{
		ASSERT(0);
	}

	/*
	motion_vector_count = 1;
	m_mv_format = field;//frame;//field;
	m_dmv = 1;
	*/

	uint8 m_motion_vertical_field_select[2][2];

//	motion_vector_count = 1;	// TODO remove
//	m_mv_format = frame;
	//m_dmv = 1;

	if (motion_vector_count == 1)
	{
		if ((m_mv_format == field) && (m_dmv != 1))
		{
			m_motion_vertical_field_select[0][s] = m_file->getbit();
		}
		motion_vector(0, s);
	}
	else
	{
		if ((m_mv_format == field) && (m_dmv != 1))
		{
			m_motion_vertical_field_select[0][s] = m_file->getbit();
		}
		motion_vector(0, s);

		if ((m_mv_format == field) && (m_dmv != 1))
		{
			m_motion_vertical_field_select[1][s] = m_file->getbit();
		}
		motion_vector(1, s);
	}
}

void PictureDecoder::motion_vector(int r, int s)
{
	char m_dmvector[2];

// t=0
	m_motion_code[r][s][0] = getvariablebits(m_file, tab_B10, 11) - 16;	// 1-11

	if ((m_f_code[s][0] != 1) && (m_motion_code[r][s][0] != 0))
	{
		m_motion_residual[r][s][0] = m_file->getnbits(m_f_code[s][0] - 1);	//1-8
	}

	if (m_dmv == 1)
	{
		//	1-2
		if (m_file->getbit() == 0)
			m_dmvector[0] = 0;
		else if (m_file->getbit() == 0)
			m_dmvector[0] = 1;
		else
			m_dmvector[0] = -1;
	}

// t=1
	m_motion_code[r][s][1] = getvariablebits(m_file, tab_B10, 11) - 16;	// 1-11

	if ((m_f_code[s][1] != 1) && (m_motion_code[r][s][1] != 0))
	{
		m_motion_residual[r][s][1] = m_file->getnbits(m_f_code[s][1] - 1);	//	1-8
	}

	if (m_dmv == 1)
	{
		//	1-2
		if (m_file->getbit() == 0)
			m_dmvector[1] = 0;
		else if (m_file->getbit() == 0)
			m_dmvector[1] = 1;
		else
			m_dmvector[1] = -1;
	}
}

int PictureDecoder::coded_block_pattern()
{
	int cbp_index = getvariablebits(m_file, tab_B9, 9);

	int cbp = tab_Cbp[cbp_index];

#ifdef _DEBUG
	if (m_sequence->m_chroma_format == 1)
	{
		;//ASSERT(cbp != 0);	// ??
	}
#endif

	if (m_sequence->m_chroma_format == 2)	// 4:2:2
	{
		ASSERT(0);
		int coded_block_pattern_1 = m_file->getnbits(2);
	}
	else if (m_sequence->m_chroma_format == 3)	// 4:4:4
	{
		ASSERT(0);
		int coded_block_pattern_2 = m_file->getnbits(6);
	}

	return cbp;
}

void PictureDecoder::decode_block(int i, short QFS[64])
{
	short QF[64];
	short* F = QFS;

// Inverse scan
	{
		for (int v = 0; v < 8; v++)
		{
			for (int u = 0; u < 8; u++)
			{
				QF[v*8+u] = QFS[scan[m_alternate_scan][v][u]];
			}
		}
	}

	uint8 W/*[1]*/[64];
//	uint8 (*W)[8];
// Inverse scan for matrix download
	{

		uint8 *W_;
		
		if (m_macroblock_intra)
		{
			W_ = i < 4? m_sequence->m_intra_quantiser_matrix: m_sequence->m_chroma_intra_quantiser_matrix;
		
			for (int v = 0; v < 8; v++)
			{
				for (int u = 0; u < 8; u++)
				{
				//	W[v][u] = W_[scan[m_alternate_scan][v][u]];
					W[v*8+u] = W_[v*8+u];
				}
			}
		}
		else
		{
			W_ = i < 4? m_sequence->m_non_intra_quantiser_matrix: m_sequence->m_chroma_non_intra_quantiser_matrix;

			for (int v = 0; v < 8; v++)
			{
				for (int u = 0; u < 8; u++)
				{
					W[v*8+u] = W_[scan[m_alternate_scan][v][u]];
//					W[v][u] = W_[v*8+u];
				}
			}
		}

	//	W = (uint8 (*)[8])(W_);
	}

// Inverse quantization

	{
	//	int u, v;

		//int intra_dc_mult = tab_intra_dc_mult[m_intra_dc_precision];
		int intra_dc_shift = 3-m_intra_dc_precision;

		int quantiser_scale = QuantizerScale[m_quantiser_scale_code][m_q_scale_type];

		if (m_sequence->m_mpeg1)
		{
			if (m_macroblock_intra)
			{
				F[0] = QF[0] << intra_dc_shift;//* intra_dc_mult;

				for (int i = 1; i < 64; i++)
				{
					short f = ( QF[i] * W[i] * quantiser_scale) >> 4;

					if ((f & 1) == 0)
						f = f - Sign(f);

					if (f > 2047) f = 2047;
					else if (f < -2048) f = -2048;

					F[i] = f;
				}
			}
			else
			{
				for (int i = 0; i < 64; i++)
				{
					F[i] = ( ( ( QF[i] *  2 ) + Sign(QF[i])) * W[i] * quantiser_scale ) >> 5;
				}
			}

#if 0
			for (v = 0; v < 8; v++)
			{
				for (u = 0; u < 8; u++)
				{
					if ((u == 0) && (v == 0) && (m_macroblock_intra))
					{
						F[v][u] = intra_dc_mult * QF[v][u];
					}
					else
					{
						if (m_macroblock_intra)
						{
							F[v][u] = ( QF[v][u] * W/*[w]*/[v][u] * quantiser_scale * 2 ) / 32;

							if ((F[v][u] & 1) == 0)
								F[v][u] = F[v][u] - Sign(F[v][u]);

							if (F[v][u] > 2047) F[v][u] = 2047;
							else if (F[v][u] < -2048) F[v][u] = -2048;
						}
						else
						{
							F[v][u] = ( ( ( QF[v][u] *  2 ) + Sign(QF[v][u])) * W/*[w]*/[v][u]
																* quantiser_scale ) / 32;
						}
					}
				}

				/*
				if (i == 0)
				{
					F[0][0] += m_dc_y_past;
				}
				else if (i < 4)
				{
					F[0][0] = m_dc_y_past + QFS[0]*8;
				}

				m_dc_y_past = F[0][0];
				*/
			}
#endif
		}
		else	// mpeg2
		{
		//	short F_[64];
		//	short F__[64];
			short* F__ = F;

			if (m_macroblock_intra)
			{
			//	F__[0] = intra_dc_mult * QF[0];	// TODO, use shift instead of multiply
				F__[0] = QF[0] << intra_dc_shift;

				for (int i = 1; i < 64; i++)
				{
					F__[i] = (QF[i] * W[i] * quantiser_scale) >> 4;
				}
				/*
				for (v = 0; v < 8; v++)
				{
					for (u = 0; u < 8; u++)
					{
						if ((u == 0) && (v == 0))
						{
							F__[v][u] = intra_dc_mult * QF[v][u];
						}
						else
						{
							F__[v][u] = ( QF[v][u] * W[v][u] * quantiser_scale) / 16;
						}
					}
				}
				*/
			}
			else
			{
				for (int i = 0; i < 64; i++)
				{
					F__[i] = ( ( ( QF[i] *  2 ) + Sign(QF[i])) * W[i] * quantiser_scale ) >> 5;
				}
				/*
				for (v = 0; v < 8; v++)
				{
					for (u = 0; u < 8; u++)
					{
						F__[v][u] = ( ( ( QF[v][u] *  2 ) + Sign(QF[v][u])) * W[v][u]
															* quantiser_scale ) / 32;
					}
				}
				*/
			}

			int sum = 0;
			for (int i = 0; i < 64; i++)
			{
						if (F__[i] > 2047)	F[i] = 2047;
				else	if (F__[i] < -2048)	F[i] = -2048;
				else									F[i] = F__[i];

				sum += F[i];
				//F[i] = F_[i];
			}

			if ((sum & 1) == 0)	// even
			{
				if ((F[63] & 1) != 0)
				{
					F[63] = F[63] - 1;
				}
				else
				{
					F[63] = F[63] + 1;
				}
			}

			/*
			int sum = 0;
			for (v = 0; v < 8; v++)
			{
				for (u = 0; u < 8; u++)
				{
							if (F__[v][u] > 2047)	F_[v][u] = 2047;
					else	if (F__[v][u] < -2048)	F_[v][u] = -2048;
					else									F_[v][u] = F__[v][u];

					sum += F_[v][u];
					F[v][u] = F_[v][u];
				}
			}

			if ((sum & 1) == 0)	// even
			{
				if ((F[7][7] & 1) != 0)
				{
					F[7][7] = F_[7][7] - 1;
				}
				else
				{
					F[7][7] = F_[7][7] + 1;
				}
			}
			*/
		}
	}
}

void PictureDecoder::block(int i, short QFS[64])
{
	int cc = cctab[i][m_sequence->m_chroma_format-1];

	unsigned int n;
	bool b14;

	if (m_macroblock_intra)
	{
		//int dc_dct_differential;
		int dc_dct_size;

		if (i < 4)	// cc is zero	// luminance
		{
			dc_dct_size = getvariablebits(m_file, tab_B12, 9);
		//	dc_dct_size = m_file->getvariablebits(tab_B12, 9);

			/*
			if (dc_dct_size != 0)
			{
				dc_dct_differential = m_file->getnbits(dc_dct_size);
			}
			*/
		}
		else	// cc is non-zero (chrominance)
		{
			dc_dct_size = getvariablebits(m_file, tab_B13, 10);
			/*
			if (dc_dct_size != 0)
			{
			}
			*/
		}

	// First coeficient for intra

		if (dc_dct_size == 0)
		{
		//	dct_diff = 0;
			QFS[0] = m_dc_dct_pred[cc];
		}
		else
		{
			int dc_dct_differential = m_file->getnbits(dc_dct_size);
			int dct_diff;
			int half_range = 1<<(dc_dct_size-1);

			if (dc_dct_differential >= half_range)
				dct_diff = dc_dct_differential;
			else
				dct_diff = (dc_dct_differential + 1) - (2 * half_range);

			QFS[0] = m_dc_dct_pred[cc] + dct_diff;
			m_dc_dct_pred[cc] = QFS[0];
		}

		n = 1;	// Done first one

		if (m_intra_vlc_format == 0)
			b14 = true;
		else
			b14 = false;
	}
	else
	{
		n = 0;	// Start on first
		b14 = true;
	}

	/*
	while ( nextbits() != End of block )
		Subsequent DCT coefficients
	End of block
	*/

	//ASSERT(sizeof(tab_B14) == sizeof(tab_B15));

	bool eob_not_read = 1;
	while (eob_not_read)
	{
		//<decode VLC, decode Escape coded coefficient if required>

		int vlc;

		if (b14)
		{
			uint16 value = m_file->looknbits(16);
			if (value >= 32768)	// MSB set
			{
				if (n == 0)	// The first coefficient (never end of block)
				{
					// '1'

					vlc = 1;
					m_file->skipnbits(1);
				}
				else
				{
					// either '10' or '11'

					vlc = (value>>14) & 1;
					m_file->skipnbits(2);
				}
			}
			else
			{
				vlc = tab_B14[value].index + 2;
				m_file->skipnbits(1 + tab_B14[value].len);
			}
		}
		else
		{
			vlc = getvariablebits(m_file, tab_B15, 16);
		}

		//if ( <decoded VLC indicates End of block> )
		if (vlc == 0)
		{
			eob_not_read = 0;
		// set remaining to 0
			while (n < 64)
			{
				QFS[n] = 0;
				n++;
			}
		}
		else
		{
			unsigned int run;
			short signed_level;

			if (vlc == 16)	// Escape
			{
				run = m_file->getnbits(6);

				if (m_sequence->m_mpeg1)
				{
					char level = m_file->getnbits(8);

				// not fully tested
					if (level == 0)
						signed_level = (unsigned short)m_file->getnbits(8);
					else if ((uint8)level == 128)
						signed_level = m_file->getnbits(8) | 0xff00;
					else
						signed_level = level;
				}
				else
				{
				// not fully tested
					signed_level = m_file->getnbits(12);

				//	ASSERT(signed_level != 0);
					if (signed_level == 0)
						THROW(-1);

					if (signed_level > 2047)
					{
						//signed_level = -(signed_level-2047);
						signed_level |= 0xf000;
					}
				}
			}
			else
			{
				run = rl_B14[vlc][0];
				signed_level = rl_B14[vlc][1];

				int s = m_file->getbit();

				if (s == 1)
					signed_level = -signed_level;

			/*
				int level;
				run = rl_B14[vlc][0];
				level = rl_B14[vlc][1];

				int s = m_file->getbit();

				if (s == 0)
					signed_level = level;
				else
					signed_level = -level;
					*/
			}

			if (n+run+1 > 64)
			{
				//MessageBeep(-1);
				//ASSERT(0);
				THROW(-1);
			}

		//	else
			{
				for (int m = 0; m < run; m++)
				{
					QFS[n] = 0;
					n++;
				}
				QFS[n] = signed_level;
				n++;
				/*
				if (n == 64)
				{
				//	MessageBeep(-1);
			//		break;
				}
				*/
			}
		}
	}
}

Picture::Picture()
{
	m_decoder = NULL;
	m_iGroup = -1;
	m_keepAliveCount = 0;
}

}	// Media
}

#include "stdafx.h"
#include "LXML.h"
#include "LXML2.h"

#include "DTDParser.h"
#include "DTDDocument.h"
#include "LDTDElement.h"
#include "Comment.h"
#include "DOMLocator.h"

//#include "../LXUI/http.h"

#if 0

namespace LXML
{
class CLDOMError;

CLDOMError* CreateDOMError(LDOMErrorSeverity severity, StringW message, ILDOMLocator* location);

/*
Validity constraint: Element Valid

An element is valid if there is a declaration matching elementdecl where the Name
matches the element type, and one of the following holds:

The declaration matches EMPTY and the element has no content.

The declaration matches children and the sequence of child elements belongs to the
language generated by the regular expression in the content model, with optional
white space (characters matching the nonterminal S) between the start-tag and the first child element, between child elements, or between the last child element and the end-tag. Note that a CDATA section containing only white space does not match the nonterminal S, and hence cannot appear in these positions.

The declaration matches Mixed and the content consists of character data and child
elements whose types match names in the content model.

The declaration matches ANY, and the types of any child elements have been declared.
*/

//////////////////////////////////////////////////////////////////////
// CDTDParser

ILDOMLocator* CDTDParser::GetCurrentLocation()
{
	CLDOMLocator* locator = new CLDOMLocator;
//	CComObject<CLDOMLocator>::CreateInstance(&locator);
	if (locator)
	{
		locator->m_offset = m_fpos;
		locator->m_lineNumber = m_line;
		locator->m_columnNumber = m_column;
		locator->m_uri = m_url;
	}

	return locator;
}

bool CDTDParser::eof()
{
	if (m_fpos >= m_textLen)
		return true;

	if (m_textData[m_fpos] == m_eof)
	{
//		ungetcnext();
		return true;
	}

//	ungetcnext();

	/*
	long textLen;
	m_textDoc->get_len(&textLen);

	if (m_fpos < textLen)
		return FALSE;
	else
		return TRUE;
		*/

	return false;
}

int CDTDParser::_getcnext()
{
//	long textLen;
//	m_textDoc->get_len(&textLen);

	int c = m_textData[m_fpos];

	if (c != m_eof)//m_fpos < textLen)
	{
		m_fpos++;

		if (c == '\n')
		{
			m_line++;
			m_column = 0;
		}
		else
			m_column++;

		return c;
	}
	else
		return EOF;
}

void CDTDParser::_ungetcnext()
{
	//if (m_fpos > 0)
	{
		//long textLen;
		//m_textDoc->get_len(&textLen);

		//BSTR textData;
		//m_textDoc->get_data(&textData);

		m_fpos--;

		if (m_textData[m_fpos] == '\n')
		{
			m_line--;
		}
	}
#if 0
	else
		ASSERT(0);
#endif
}

int CDTDParser::getcnext()
{
	if (m_pInsideEntity)
	{
		unsigned long textLen = m_pInsideEntity->m_value.length();
		const OLECHAR* textData = m_pInsideEntity->m_value.c_str();

		if (m_efpos < textLen)
		{
			int c = textData[m_efpos++];
			return c;
		}
		else
		{
			m_pInsideEntity = NULL;
		}
	}

//	long textLen;
//	m_textDoc->get_len(&textLen);

//	BSTR textData;
//	m_textDoc->get_data(&textData);

	int c = m_textData[m_fpos];

	if (c!=m_eof/*m_fpos < textLen*/)
	{
		if (c == L'%')
		{
			if (/*m_fpos < textLen-1 &&*/ !iswspace(m_textData[m_fpos+1]))
			{
				m_fpos++;

				sysstring name = OLESTR("");
				while (!eof()/*m_fpos < textLen*/)
				{
					int c = _getcnext();//m_textData[m_fpos++];

					if (iswspace(c))
					{
						_ungetcnext();
						//m_fpos--;
						break;
					}

					if (c == L';')
					{
						_ungetcnext();
						//m_fpos--;
						break;
					}

					//WCHAR c2[] = {c, 0};
					name += c;
				}

				EatChar(L';');

				CEntity* pEntity = m_dtdDocument->GetEntityByName(name);
				if (pEntity == NULL)
				{
					OLECHAR msg[1024];
					swprintf(msg, OLESTR("Usage of undeclared entity %s"), name.c_str());

					ASSERT(0);
#if 0
					handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
					throw msg;
				}

				m_pInsideEntity = pEntity;
				m_efpos = 0;

				return getcnext();
			}
		}

		m_fpos++;

		if (c == '\n')
		{
			m_line++;
			m_column = 0;
		}
		else
			m_column++;

		return c;
	}
	else
		return EOF;

	ASSERT(0);
	return 0;//getcnext();
}

int CDTDParser::getcnext_noexpand()
{
	if (m_pInsideEntity)
	{
		unsigned long textLen = m_pInsideEntity->m_value.length();
		const OLECHAR* textData = m_pInsideEntity->m_value.c_str();

		if (m_efpos < textLen)
		{
			int c = textData[m_efpos++];
			return c;
		}
		else
		{
			m_pInsideEntity = NULL;
		}
	}

//	long textLen;
//	m_textDoc->get_len(&textLen);

//	BSTR textData;
//	m_textDoc->get_data(&textData);

	int c = m_textData[m_fpos];
	m_fpos++;

	return c;
}

void CDTDParser::ungetcnext()
{
	if (m_pInsideEntity)
	{
		if (m_efpos > 0)
		{
			m_efpos--;
			return;
		}
		else
		{
			m_fpos--;	// ;
			m_fpos -= m_pInsideEntity->m_name.length();
			m_fpos--;	// %

			m_pInsideEntity = NULL;
		}
	}

	_ungetcnext();
#if 0
	if (m_fpos > 0)
	{
		long textLen;
		m_textDoc->get_len(&textLen);

		BSTR textData;
		m_textDoc->get_data(&textData);

		m_fpos--;

		if (textData[m_fpos] == '\n')
		{
			m_line--;
		}
	}
	else
		ASSERT(0);
#endif
}

sysstring CDTDParser::GetID()
{
//	SkipSpaces();

	sysstring str = OLESTR("");

	while (!eof())
	{
		OLECHAR c = getcnext();
		if (!(isalnum(c) || c == L':' || c == L'.' || c == L'-' || c == L'_'))
		{
			ungetcnext();
			break;
		}

		str += c;
	}

	if (str.length() == 0)
	{
		OLECHAR* msg = OLESTR("Expected ident");
#if 0
		handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, getcnexturrentLocation()));
#endif
		throw msg;
	}

//	SkipSpaces();

	return str;
}

void CDTDParser::GetNSID(sysstring& ns, sysstring& id)
{
	ns = OLESTR("");
	id = OLESTR("");

	sysstring str = OLESTR("");

	OLECHAR c;

	while (!eof())
	{
		c = getcnext();
		if (!(iswalnum(c) || c == ':' || c == '.' || c == '-')) break;

		if (c == ':')
		{
			ns = str;
			str = OLESTR("");
		}
		else
		{
			str += c;
		}
	}

	id = str;

	ungetcnext();
}

sysstring CDTDParser::GetString()
{
	int delimiter = getcnext();
	if (delimiter != '"' && delimiter != '\'')
	{
		ASSERT(0);
#if 0
		handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, OLESTR("Expected string delimiter"), GetCurrentLocation()));
#endif
		THROW(OLESTR("Expected string delimiter"));
	}

	sysstring str = OLESTR("");

	int c = EOF;

	while (!eof())
	{
		c = getcnext();
		if (c == delimiter)
		{
			break;
		}

		str += (WCHAR)c;
	}

	if (c != delimiter)
	{
		OLECHAR msg[256];
		swprintf(msg, OLESTR("Expected %c"), delimiter);

		ASSERT(0);
#if 0
		handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
		throw msg;
	}

	return str;
}

void CDTDParser::SkipSpaces()
{
	while (!eof())
	{
		int c = getcnext();

		if (c == '-')
		{
			int c2 = getcnext();
			if (c2 == '-')
			{
				while (!eof())
				{
					int c = getcnext_noexpand();

					if (c == '-')
					{
						int c2 = getcnext_noexpand();
						if (c2 == '-')
						{
							break;
						}
						else
						{
							ungetcnext();
						}
					}
				}
			}
			else
			{
				ungetcnext();
				ungetcnext();
				break;
			}
		}
		else if (!iswspace(c))
		{
			ungetcnext();
			break;
		}
	}
}

void CDTDParser::EatChar(int c)
{
	int c2 = getcnext();
	if (c2 != c)
	{
		OLECHAR msg[64];
		if (c2 == EOF)
			swprintf(msg, OLESTR("Expected \"%c\", but reached end of file"), c);
		else
			swprintf(msg, OLESTR("Expected \" %c \" instead of \" %c \""), c, c2);

		ASSERT(0);
#if 0
		handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
		throw msg;
	}
}

void CDTDParser::ParseComment(CLDOMComment* pComment)
{
//	int offset1 = m_fpos;
//	int offset2;

	int c;

	while (!eof())
	{
	//	offset2 = m_fpos;

		c = _getcnext();
		if (c == '-')
		{
			if (!eof())
			{
				int c2 = _getcnext();
				if (c2 == '-')
				{
					break;
				}
				_ungetcnext();
			}
		}

		/*
		if (m_document)
		*/
		{
		//	OLECHAR c2[] = {c, 0};
		//	ASSERT(0);
#if 0
			pComment->m_data += c2;
#endif
		}
	}

//	pComment->m_data = data;

//	EatChar('>');

#if 0
	int offset3 = m_fpos+1;

	ASSERT(0);
	pComment->setTextOffset(0, offset1-4);	// <!--

	pComment->setTextOffset(1, offset1);
	pComment->setTextOffset(2, offset1);

	pComment->setTextOffset(3, offset2);
	pComment->setTextOffset(4, offset2);

	pComment->setTextOffset(5, offset3);
	pComment->setTextOffset(6, offset3);
	pComment->setTextOffset(7, offset3);
	pComment->setTextOffset(8, offset3);
	pComment->setTextOffset(9, offset3);
#endif

/*
	if (m_document)
	{
		IDOMComment* comment;
		m_document->createComment(data, &comment);
		return comment;
	}
	else
		return NULL;
*/
}

/*

contentspec	::=    'EMPTY' | 'ANY' | Mixed | children 

children    ::=    (choice | seq) ('?' | '*' | '+')? 

choice		::=    '(' S? cp ( S? '|' S? cp )+ S? ')' 
seq			::=    '(' S? cp ( S? ',' S? cp )* S? ')' 

cp				::=    (Name | choice | seq) ('?' | '*' | '+')? 

Mixed			::=    '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'

*/

CCP* CDTDParser::ParseCP()
{
	CCP* pCP = NULL;

	int c;

	c = getcnext();

	if (c == '+' || c == '-')
	{
	//	c = getcnext();

		EatChar('(');
		CCPChoiceSeq* pCPChoiceSeq = ParseChoiceSeq();
		EatChar(L')');
		pCP = pCPChoiceSeq;
	}
	else if (c == L'(')	// choice | seq
	{
		CCPChoiceSeq* pCPChoiceSeq = ParseChoiceSeq();

		EatChar(L')');

		pCP = pCPChoiceSeq;
	}
	else
	{
		ungetcnext();

		SkipSpaces();

		CCPElement* pCPElement = new CCPElement;
		pCPElement->m_pDTDDocument = this;
		GetNSID(pCPElement->m_ns, pCPElement->m_name);

		SkipSpaces();

		int c = getcnext();
		if (c == L'?' || c == L'*' || c == L'+')
		{
		// Wrap the element within a ChoiceSeq group
			CCPChoiceSeq* pCPChoiceSeq = new CCPChoiceSeq;
			pCPChoiceSeq->m_pDTDDocument = this;
			pCPChoiceSeq->m_listOperator = AS_NONE;

			pCPChoiceSeq->m_children.Add(pCPElement);

			pCP = pCPChoiceSeq;
		}
		else
		{
			pCP = pCPElement;
		}

		ungetcnext();
	}

	SkipSpaces();

	if (pCP && pCP->m_type == 2)
	{
		CCPChoiceSeq* pCPChoiceSeq = (CCPChoiceSeq*)pCP;

		int c = getcnext();
		if (c == '?')
		{
			pCPChoiceSeq->m_minOccurs = 0;
			pCPChoiceSeq->m_maxOccurs = 1;
		}
		else if (c == '*')
		{
			pCPChoiceSeq->m_minOccurs = 0;
			pCPChoiceSeq->m_maxOccurs = AS_UNBOUNDED;
		}
		else if (c == '+')
		{
			pCPChoiceSeq->m_minOccurs = 1;
			pCPChoiceSeq->m_maxOccurs = AS_UNBOUNDED;
		}
		else
		{
			ungetcnext();
		}
	}

	return pCP;
}

CCPChoiceSeq* CDTDParser::ParseChoiceSeq()
{
	CCPChoiceSeq* pCPChoiceSeq = new CCPChoiceSeq;
	pCPChoiceSeq->m_pDTDDocument = this;

	SkipSpaces();

	while (!eof())
	{
		CCP* pCP = ParseCP();

		if (pCP)
		{
			pCPChoiceSeq->m_children.Add(pCP);
		}

		SkipSpaces();

		int c = getcnext();

		if (c == ')')	// end
		{
			ungetcnext();
			break;
		}

		if (c == ',')	// seq
		{
			if ((pCPChoiceSeq->m_listOperator != -1) &&
				(pCPChoiceSeq->m_listOperator != AS_SEQUENCE))
			{
			//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
			//	m_errorHandler->fatalError(locator, NULL, L"Unexpected ,");
				OLECHAR* msg = OLESTR("Unexpected ,");
				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
				throw msg;
			}

			pCPChoiceSeq->m_listOperator = AS_SEQUENCE;
		}
		else if (c == '|')	// choice
		{
			if ((pCPChoiceSeq->m_listOperator != -1) &&
				(pCPChoiceSeq->m_listOperator != AS_CHOICE))
			{
			//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
				OLECHAR* msg = OLESTR("Unexpected |");
				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
			//	m_errorHandler->fatalError(locator, NULL, L"Unexpected |");
				throw msg;
			}

			pCPChoiceSeq->m_listOperator = AS_CHOICE;
		}
		else
		{
			OLECHAR msg[64];
			swprintf(msg, OLESTR("Unexpected %c (Expected ',', '|', ')' )"), c);

		//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
		//	m_errorHandler->fatalError(locator, NULL, msg);
			ASSERT(0);
#if 0
			handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
			throw msg;
		}

		SkipSpaces();
	}

	if (pCPChoiceSeq->m_listOperator == (ASContentModelTypeOp)-1)	// ??
		pCPChoiceSeq->m_listOperator = AS_SEQUENCE;

	return pCPChoiceSeq;
}

/*
CComObject<CDTDContentModel>* CCPElement::BuildCM()
{
}
*/

void CDTDParser::ParseElementContentSpec(CLDTDElement* pElement)
{
	int c = getcnext();
	if (c == L'(')	// Mixed | children
	{
		SkipSpaces();

		int c = getcnext();
		if (c == L'#')	// Mixed
		{
			sysstring id = GetID();
			if (id != OLESTR("PCDATA"))
			{
			//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
			//	m_errorHandler->fatalError(locator, NULL, L"Expected PCDATA");
				OLECHAR* msg = OLESTR("Expected PCDATA");
				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
				throw msg;
			}

			pElement->m_pCPChoiceSeq = new CCPChoiceSeq;
			pElement->m_pCPChoiceSeq->m_listOperator = AS_ALL;

			SkipSpaces();

			int c = getcnext();
			if (c == '|')	// PCDATA mixed with elements
			{
				pElement->m_contentType = MIXED_CONTENTTYPE;
			//	pElement->m_isPCDataOnly = VARIANT_FALSE;

				while (!eof())
				{
					SkipSpaces();

					sysstring id = GetID();

					CCPChoiceSeq* pCP = new CCPChoiceSeq;
					pCP->m_minOccurs = 0;
					pCP->m_maxOccurs = AS_UNBOUNDED;
					pCP->m_listOperator = AS_NONE;

					CCPElement* pCPElement = new CCPElement;
					pCPElement->m_name = id;
					pCP->m_children.Add(pCPElement);

					pElement->m_pCPChoiceSeq->m_children.Add(pCP);

					SkipSpaces();

					int c = getcnext();
					ungetcnext();

					if (c == L')')
					{
						break;
					}

					EatChar(L'|');
				}

				EatChar(L')');
				EatChar(L'*');	// ??
			}
			else	// Only PCDATA
			{
			//	pElement->m_isPCDataOnly = VARIANT_TRUE;
				pElement->m_contentType = SIMPLE_CONTENTTYPE;

				ungetcnext();	// ungetcnext(|)

				SkipSpaces();

				EatChar(L')');

				if (getcnext() != L'*') ungetcnext();	// hmm.. ??
			}
		}
		else	// children
		{
			ungetcnext();	// ungetcnext(#)

			pElement->m_contentType = ELEMENT_CONTENTTYPE;

			pElement->m_pCPChoiceSeq = ParseChoiceSeq();

			EatChar(L')');

			int c = getcnext();

			if (c == '?')
			{
				pElement->m_pCPChoiceSeq->m_minOccurs = 0;
				pElement->m_pCPChoiceSeq->m_maxOccurs = 1;
			}
			else if (c == '*')
			{
				pElement->m_pCPChoiceSeq->m_minOccurs = 0;
				pElement->m_pCPChoiceSeq->m_maxOccurs = -1;
			}
			else if (c == '+')
			{
				pElement->m_pCPChoiceSeq->m_minOccurs = 1;
				pElement->m_pCPChoiceSeq->m_maxOccurs = -1;
			}
			else
			{
				ungetcnext();
			}
		}
	}
	else
	{
		ungetcnext();

		sysstring id = GetID();
		if (!wcscmp(id.c_str(), OLESTR("EMPTY")))
		{
			pElement->m_contentType = EMPTY_CONTENTTYPE;
		}
		else if (!wcscmp(id.c_str(), OLESTR("ANY")))
		{
			pElement->m_contentType = ANY_CONTENTTYPE;
		}
		else
		{
			OLECHAR* msg = OLESTR("Expected EMPTY or ANY");
	//		CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
			ASSERT(0);
#if 0
			handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
	//		m_errorHandler->fatalError(locator, NULL, L"Expected EMPTY or ANY");
			throw msg;
		}
	}
}

void CDTDParser::ParseElement(CLDTDElement* pElement)
{
	SkipSpaces();

	int c = getcnext();
	if (c == '(')
	{
		// TODO
		while (!eof())
		{
			c = getcnext();
			if (c == ')')
			{
				break;
			}
		}
	}
	else
	{
		ungetcnext();
		GetNSID(pElement->m_ns, pElement->m_name);
		if (pElement->m_name == L"BODY")
		{
			MessageBeep(-1);
		}
	}

	/*
	if (!wcscmp(pElement->m_name, L"p"))
	{
	}
	*/

	SkipSpaces();

	c = getcnext();
	if (c == '-')
	{
		SkipSpaces();
		int c = getcnext();
		ASSERT(c == '-' || c == 'O');
	}
	else if (c == 'O')
	{
		SkipSpaces();
		int c = getcnext();
		ASSERT(c == '-' || c == 'O');
	}
	else
	{
		ungetcnext();
	}

	SkipSpaces();

	ParseElementContentSpec(pElement);

	SkipSpaces();
}

void CDTDParser::ParseAttlist(CAttlist* pAttlist)
{
	SkipSpaces();

	int c = getcnext();
	if (c == '(')
	{
		// TODO
		while (!eof())
		{
			c = getcnext();
			if (c == ')')
			{
				break;
			}
		}
	}
	else
	{
		ungetcnext();
		GetNSID(pAttlist->m_ns, pAttlist->m_name);
	}

// Parse all attributes
	while (!eof())
	{
		SkipSpaces();

		int c = getcnext();
		ungetcnext();

		if (c == L'>')
		{
			break;
		}

		CAttribute* pAtt = new CAttribute;
		pAttlist->m_attributes.Add(pAtt);

		SkipSpaces();
		/*
		c = getcnext();
		if (c == '(')
		{
			// TODO
			while (!eof())
			{
				c = getcnext();
				if (c == ')')
				{
					break;
				}
			}
		}
		else
		{
			ungetcnext();
			*/
		pAtt->m_name = GetID();

		SkipSpaces();

		c = getcnext();
		if (c == L'(')	// Enumeration
		{
			while (!eof())
			{
				SkipSpaces();

				sysstring e = GetID();
				pAtt->m_enums.Add(e);

				SkipSpaces();

				int c = getcnext();
				ungetcnext();
				if (c == L')')
				{
					break;
				}

				EatChar(L'|');
			}

			EatChar(L')');
		}
		else
		{
			ungetcnext();

			SkipSpaces();

			sysstring str = GetID();
			if (!wcscmp(str.c_str(), OLESTR("NOTATION")))	// NotationType
			{
				SkipSpaces();
				EatChar(L'(');

				while (!eof())
				{
					SkipSpaces();

					sysstring e = GetID();
					//pAtt->m_enums.Add(e);

					SkipSpaces();

					int c = getcnext();
					ungetcnext();
					if (c == L')')
					{
						break;
					}

					EatChar(L'|');
				}

				EatChar(L')');
			}
			else
			{
				if (!wcscmp(str.c_str(), OLESTR("CDATA")))	// StringType
				{
				}
				else
				{
					if (!wcscmp(str.c_str(), OLESTR("ID")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("IDREF")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("IDREFS")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("ENTITY")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("ENTITIES")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("NMTOKEN")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("NMTOKENS")))
					{
					}
					else if (!wcscmp(str.c_str(), OLESTR("NAME")))	// SGML
					{
					}
					else
					{
						OLECHAR msg[512];
						swprintf(msg, OLESTR("Unexpected %.511s"), str.c_str());

//						CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
//						m_errorHandler->fatalError(locator, NULL, msg);
						ASSERT(0);
#if 0
						handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
						throw msg;
					}
				}
			}
		}

	// Get Default value

		SkipSpaces();

		c = getcnext();
		if (c == L'#')
		{
			sysstring str = GetID();
			if (!wcscmp(str.c_str(), OLESTR("REQUIRED")))
			{
				pAtt->m_defaultType = REQUIRED_VC;
			}
			else if (!wcscmp(str.c_str(), OLESTR("IMPLIED")))
			{
				pAtt->m_defaultType = DEFAULT_VC;
			}
			else if (!wcscmp(str.c_str(), OLESTR("FIXED")))
			{
				SkipSpaces();
				pAtt->m_value = GetString();
				pAtt->m_defaultType = FIXED_VC;
			}
			else
			{
				//CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
				//m_errorHandler->fatalError(locator, NULL, L"Expected REQUIRED|IMPLIED|FIXED");
				OLECHAR* msg = OLESTR("Expected REQUIRED|IMPLIED|FIXED");
				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
				throw msg;
			}
		}
		else
		{
			ungetcnext();
			pAtt->m_value = GetString();
		}
	}
}

void CDTDParser::ParseEntity(CEntity* pEntity)
{
//	USES_CONVERSION;

	SkipSpaces();
	int c = getcnext();
	if (c == L'%')
		pEntity->m_c = c;
	else
	{
		ungetcnext();
		pEntity->m_c = 0;
	}

	SkipSpaces();
	pEntity->m_name = GetID();

#if 0
	if (!wcscmp(pEntity->m_name, OLESTR("SVG.Animation.class")))
	{
		MessageBeep((UINT)-1);
	}

	if (!wcscmp(pEntity->m_name, OLESTR("SVG.desc.qname")))
	{
		MessageBeep((UINT)-1);
	}
#endif

	SkipSpaces();

	if (pEntity->m_c == L'%')	// PEDecl (parameter entity)
	{
		int delimiter = getcnext();
		ungetcnext();

		if (delimiter == '"' || delimiter == '\'')
		{
			pEntity->m_value = GetString();
		}
		else
		{
			sysstring s = GetID();

			SkipSpaces();

			sysstring n = GetString();

			SkipSpaces();

			sysstring url = GetString();

#if _WINDOWS
			TCHAR result[2048];
			{
				DWORD resultLen = sizeof(result);
				InternetCombineUrlA(ConvertS2A(m_url).c_str(), ConvertS2A(url).c_str(), result, &resultLen, 0);
			}
			
			CDTDParser parser;
			parser.m_dtdDocument = m_dtdDocument;
#if 0
			parser.m_parentNode = m_dtdDocument;
#endif
			parser.m_errorHandler = m_errorHandler;
			parser.loadURL(ConvertA2S(result));
#else
			ASSERT(0);
#endif
		}

		SkipSpaces();
	}
	else	// GEDecl (general entity)
	{
// '<!ENTITY' S Name S EntityDef S? '>'
// EntityDef   ::=    EntityValue | (ExternalID NDataDecl?)
// ExternalID  ::=    'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral  
// NDataDecl   ::=    S 'NDATA' S Name 

		int c = getcnext();

		if (c == L'\"' || c == L'\'')	// EntityValue
		{
			ungetcnext();
			pEntity->m_value = GetString();

			TRACE("Entity: %S value: %S\n", pEntity->m_name.c_str(), pEntity->m_value.c_str());

			SkipSpaces();
		}
		else
		{
			ungetcnext();
			SkipSpaces();

			sysstring s = GetID();

			SkipSpaces();

			if (!wcscmp(s.c_str(), OLESTR("SYSTEM")))
			{
				pEntity->m_system = GetString();
			}
			else if (!wcscmp(s.c_str(), OLESTR("PUBLIC")))
			{
				pEntity->m_public = GetString();
			}
			else if (!wcscmp(s.c_str(), OLESTR("CDATA")))
			{
			//	ungetcnext();
				SkipSpaces();
				pEntity->m_value = GetString();

				TRACE("Entity: %S value: %S\n", pEntity->m_name.c_str(), pEntity->m_value.c_str());

				SkipSpaces();
			}
			else
			{
				OLECHAR* msg = OLESTR("Expected SYSTEM or PUBLIC");

				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
				throw msg;
			}

			SkipSpaces();

			c = getcnext();
			if (iswalpha(c))
			{
				sysstring ndata = GetID();

				if (!wcscmp(ndata.c_str(), OLESTR("NDATA")))
				{
					// Unparsed entity
				}
				else
				{
					OLECHAR msg[256];
					swprintf(msg, OLESTR("Unexpected %.255s"), ndata.c_str());

				//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
				//	m_errorHandler->fatalError(locator, NULL, msg);
					ASSERT(0);
#if 0
					handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
					throw msg;
				}
			}
			else
				ungetcnext();
		}
	}
}

/*
[82]    NotationDecl    ::=    '<!NOTATION' S Name S (ExternalID | PublicID) S? '>' [VC: Unique Notation Name] 
[83]    PublicID    ::=    'PUBLIC' S PubidLiteral  
*/
void CDTDParser::ParseNotation(CNotation* pNotation)
{
	SkipSpaces();
	sysstring name = GetID();

	SkipSpaces();

	sysstring id = GetID();

	SkipSpaces();

	if (!wcscmp(id.c_str(), OLESTR("SYSTEM")))
	{
		sysstring systemLiteral = GetString();
	}
	else if (!wcscmp(id.c_str(), OLESTR("PUBLIC")))
	{
		sysstring publicLiteral = GetString();

		int c = getcnext();
		ungetcnext();

		if (c == L'\'' || c == L'\"')
		{
			sysstring systemLiteral = GetString();
		}
	}
	else
	{
//		CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
//		m_errorHandler->fatalError(locator, NULL, L"Expected SYSTEM or PUBLIC");
		OLECHAR* msg = OLESTR("Expected SYSTEM or PUBLIC");
		ASSERT(0);
#if 0
		handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
		throw msg;
	}

	SkipSpaces();
}

void CDTDParser::IgnoreSectContents()
{
	while (!eof())
	{
	//	int c = _getcnext();
		if (_getcnext() == L'<')
		{
			if (_getcnext() == L'!')
			{
				if (_getcnext() == L'[')
				{
					IgnoreSectContents();	// Recurse
				}
				else
					_ungetcnext();
			}
			else
				_ungetcnext();
		}
		else
		{
			_ungetcnext();
			if (_getcnext() == ']')
			{
				if (_getcnext() == ']')
				{
					if (_getcnext() == '>')
					{
						_ungetcnext();
						_ungetcnext();
						_ungetcnext();
						break;
					}
					else
						_ungetcnext();
				}
				else
					_ungetcnext();
			}
		}
	}

	EatChar(L']');
	EatChar(L']');
	EatChar(L'>');
}

void CDTDParser::IncludeSect()
{
	SkipSpaces();

	ExtSubsetDecl();

	EatChar(L']');
	EatChar(L']');
	EatChar(L'>');
}

/*
extSubsetDecl    ::=    ( markupdecl | conditionalSect | DeclSep)* 
*/

void CDTDParser::ExtSubsetDecl()
{
	while (!eof())
	{
		int c = getcnext();

		if (c == L'<')
		{
			int c = getcnext();

			if (c == L'!')
			{
				int c2 = getcnext();
				if (c2 == '-')
				{
					EatChar(L'-');
					//ParseCommentNode();

#if 0
					CComObject<CLDOMComment>* pComment;
					CComObject<CLDOMComment>::CreateInstance(&pComment);
					pComment->AddRef();
#endif
#if 0
					pComment->m_pDTDDocument = this;
#endif

					ParseComment(NULL/*pComment*/);

					// TODO??, should use m_parentNode ??
					//m_dtdDocument->m_childNodes->m_items.Add(pComment);
				//	m_parentNode->appendChild(pComment, NULL);

					//pComment->Release();

					EatChar(L'>');
				}
				else if (c2 == L'[')
				{
					SkipSpaces();
					sysstring conditionalName = GetID();

					if (!wcscmp(conditionalName.c_str(), OLESTR("IGNORE")))
					{
						SkipSpaces();
						EatChar(L'[');

						IgnoreSectContents();
					}
					else if (!wcscmp(conditionalName.c_str(), OLESTR("INCLUDE")))
					{
						SkipSpaces();
						EatChar(L'[');

						IncludeSect();
					}
					else
					{
						OLECHAR msg[256];
						swprintf(msg, OLESTR("Expected IGNORE | INCLUDE instead of %.64s"), conditionalName.c_str());

					//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
					//	m_errorHandler->fatalError(locator, NULL, msg);
						ASSERT(0);
#if 0
						handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
						throw msg;
					}
				}
				else
				{
					ungetcnext();

					int fpos0 = m_fpos-2;

					sysstring id = GetID();

					if (!wcscmp(id.c_str(), OLESTR("ENTITY")))
					{
						CEntity* pEntity = new CEntity;
				//		pEntity->m_ownerDocument = m_document;

						pEntity->m_pDTDDocument = this;
						m_dtdDocument->m_entityList.Add(pEntity);
					//	m_parentNode->appendChild(pEntity, NULL);

						ParseEntity(pEntity);
					EatChar(L'>');
					}
					else if (!wcscmp(id.c_str(), OLESTR("NOTATION")))
					{
						ASSERT(0);
#if 0
						CComObject<CNotation>* pNotation;
						CComObject<CNotation>::CreateInstance(&pNotation);
						pNotation->AddRef();
						pNotation->m_ownerDocument = m_document;

						pNotation->m_pDTDDocument = this;
						//m_entityList.Add(pEntity);
						m_parentNode->appendChild(pNotation, NULL);

						ParseNotation(pNotation);
					EatChar(L'>');
#endif
					}
					else if (!wcscmp(id.c_str(), OLESTR("ELEMENT")))
					{
						CLDTDElement* pElement = new CLDTDElement;
					//	CComObject<CLDTDElement>::CreateInstance(&pElement);
					//	pElement->AddRef();
					//	pElement->m_ownerDocument = m_document;

						/*
						pElement->setTextOffset(0, fpos0);
						pElement->setTextOffset(1, fpos0);
						pElement->setTextOffset(2, fpos0);
						*/

						pElement->m_pDTDDocument = this;
						m_dtdDocument->m_elementList.Add(pElement);
					//	m_parentNode->appendChild(pElement, NULL);

						ParseElement(pElement);
					EatChar(L'>');
/*
						pElement->setTextOffset(3, m_fpos);
						pElement->setTextOffset(4, m_fpos);
						pElement->setTextOffset(5, m_fpos);
						pElement->setTextOffset(6, m_fpos);
						pElement->setTextOffset(7, m_fpos);
						pElement->setTextOffset(8, m_fpos);
						pElement->setTextOffset(9, m_fpos);
						*/
					}
					else if (!wcscmp(id.c_str(), OLESTR("ATTLIST")))
					{
						CAttlist* pAttlist = new CAttlist;
					//	CComObject<CAttlist>::CreateInstance(&pAttlist);
					//	pAttlist->AddRef();
					//	pAttlist->m_ownerDocument = m_document;

						pAttlist->m_pDTDDocument = this;
						m_dtdDocument->m_attlistList.Add(pAttlist);
					//	m_parentNode->appendChild(pAttlist, NULL);

						ParseAttlist(pAttlist);
					EatChar(L'>');
					}
					else
					{
						OLECHAR msg[256];
						swprintf(msg, OLESTR("Expected ENTITY | ELEMENT | ATTLIST | NOTATION instead of %.64s"), id.c_str());

					//	CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
					//	m_errorHandler->fatalError(locator, NULL, msg);
						ASSERT(0);
#if 0
						handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
						throw msg;
					}
				}
			}
			else
			{
				OLECHAR* msg = OLESTR("Expected !");
				ASSERT(0);
#if 0
				handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
				throw msg;
			}
		}
		else
		{
			ungetcnext();
			break;

			/*
			CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
			m_errorHandler->fatalError(locator, NULL, L"Expected <");
			*/
		}

		SkipSpaces();
	}
}

HRESULT CDTDParser::Parse()
{
	m_line = 0;
	m_fpos = 0;
	m_pInsideEntity = NULL;

	try
	{
		SkipSpaces();

	// Read <?xml ... >
		EatChar('<');

		int c = _getcnext();
		if (c == '?')
		{
	//		ParseXMLHeader();
			while (!eof())
			{
				int c = _getcnext();
				if (c == L'>')
				{
					_ungetcnext();
					break;
				}
			}

			EatChar(L'>');
		}
		else
		{
			ungetcnext();
			ungetcnext();
		}

		Parse2();

		if (!eof())
		{
//			CComQIPtr<ILDOMLocator> locator = GetCurrentLocation();
//			m_errorHandler->fatalError(locator, NULL, L"Expected eof marker");
			OLECHAR* msg = OLESTR("Expected eof marker");
			ASSERT(0);
#if 0
			handleError(CreateDOMError(LSEVERITY_FATAL_ERROR, msg, GetCurrentLocation()));
#endif
			throw msg;
		}
	}
	catch (OLECHAR* msg)
	{
		OLECHAR msg2[512];
		swprintf(msg2, OLESTR("DTD ERROR: %s\n"), msg);
		TRACE(msg2);

		return E_FAIL;
	}

	return S_OK;
}

HRESULT CDTDParser::Parse2()
{
	try
	{
		m_pInsideEntity = NULL;

		SkipSpaces();

		ExtSubsetDecl();

		TRACE("...CDTDParser::Parse2()\n");
	}
	catch (OLECHAR* msg)
	{
		OLECHAR msg2[512];
		swprintf(msg2, OLESTR("DTD ERROR: %s\n"), msg);
		TRACE(msg2);

		return E_FAIL;
	}

	return S_OK;
}

HRESULT CDTDParser::loadURL(StringW* url)
{
	m_url = url;

	UrlBinding binding;
	ISequentialByteStream* stream = binding.BindToObject(url, NULL);

	sysstring data;
	while (1)
	{
		uint8 buf[512];
		long nRead = stream->Read(buf, 512);
		for (int i = 0; i < nRead; i++)
		{
			data += buf[i];
		}
		if (nRead != 512)
			break;
	}
//	StringA filename = DownloadFile(ConvertS2A(url));

	/*
	HANDLE hFile = CreateFile(filename.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD nRead;
	uint8* buffer = NULL;// = new uint8[512];
	int len = 0;
	do
	{
		buffer = (uint8*)realloc(buffer, len+512);
		ReadFile(hFile, buffer+len, 512, &nRead, NULL);
		len += nRead;
	}
	while (nRead == 512);

	CloseHandle(hFile);

	OLECHAR* textData = new OLECHAR[len];
	m_textLen = len;
	for (int i = 0; i < len; i++)
	{
		textData[i] = buffer[i];
	}

	delete [] buffer;
*/
	m_textLen = data.Length();

	m_textData = data.c_str();
	data.Detach();

	Parse();

#if 0

	CComQIPtr<ITextData, &IID_ITextData> textDoc;
	if (SUCCEEDED(textDoc.CoCreateInstance(CLSID_TextData)))
	{
		if (SUCCEEDED(textDoc->load(pathName)))
		{
			textDoc->get_data(&m_textData);

			HRESULT hr = Parse();

		// Return S_OK regardless of hr since it could have partially succeeded?
			return S_OK;
		}
	}
#endif
	return E_FAIL;
}

}	// LXML

#endif